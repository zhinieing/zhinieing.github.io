<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 应用架构]]></title>
    <url>%2F2018%2F04%2F05%2FAndroid%20%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[关于 Android 架构的讨论，MVC、MVP 和 MVVM 不绝于耳，后面又有模块化和插件化。下面主要对比前三者的异同，以及具体介绍 Google 推出的 Architecture Components 开源库。 先上结论： MVC：Model-View-Controller，经典模式，很容易理解，主要缺点有两个： View 对 Model 的依赖，会导致 View 也包含了业务逻辑 Controller 会变得很厚很复杂 MVP：Model-View-Presenter，MVC 的一个演变模式，将 Controller 换成了 Presenter，主要为了解决上述第一个缺点，将 View 和 Model 解耦，不过第二个缺点依然没有解决。 MVVM：Model-View-ViewModel，是对 MVP 的一个优化模式，采用了双向绑定：View 的变动，自动反映在 ViewModel，反之亦然。 MVC 我们平时写的 Demo 都是 MVC，controller 就是我们的 activity，model（数据提供者）就是读取数据库，网络请求这些我们一般有专门的类处理，View 一般用自定义控件。 在实际开发中，我们的 activity 代码其实是越来越多，model 和 controller 根本没有分离，控件也需要关系数据和业务，才能知道自己怎么展示。 MVP 上图可以看出，从 MVC 中 View 被拆成了 Presenter 和 View，真正实现了逻辑处理和 View 的分离。 Model 层123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**定义业务接口*/public interface IUserBiz&#123; public void login(String username, String password, OnLoginListener loginListener);&#125;/**结果回调接口*/public interface OnLoginListener&#123; void loginSuccess(User user); void loginFailed();&#125;/**具体Model的实现*/public class UserBiz implements IUserBiz&#123; @Override public void login(final String username, final String password, final OnLoginListener loginListener) &#123; //模拟子线程耗时操作 new Thread() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //模拟登录成功 if ("zhy".equals(username) &amp;&amp; "123".equals(password)) &#123; User user = new User(); user.setUsername(username); user.setPassword(password); loginListener.loginSuccess(user); &#125; else &#123; loginListener.loginFailed(); &#125; &#125; &#125;.start(); &#125;&#125; View 层View 层是以接口的形式定义，我们不关心数据，不关心逻辑处理！只关心和用户的交互。 1234567891011public interface IUserLoginView&#123; String getUserName(); String getPassword(); void clearUserName(); void clearPassword(); void showLoading(); void hideLoading(); void toMainActivity(User user); void showFailedError();&#125; 然后 Activity 实现这个这个接口： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class UserLoginActivity extends ActionBarActivity implements IUserLoginView&#123; private EditText mEtUsername, mEtPassword; private Button mBtnLogin, mBtnClear; private ProgressBar mPbLoading; private UserLoginPresenter mUserLoginPresenter = new UserLoginPresenter(this); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_user_login); initViews(); &#125; private void initViews() &#123; mEtUsername = (EditText) findViewById(R.id.id_et_username); mEtPassword = (EditText) findViewById(R.id.id_et_password); mBtnClear = (Button) findViewById(R.id.id_btn_clear); mBtnLogin = (Button) findViewById(R.id.id_btn_login); mPbLoading = (ProgressBar) findViewById(R.id.id_pb_loading); mBtnLogin.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mUserLoginPresenter.login(); &#125; &#125;); mBtnClear.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mUserLoginPresenter.clear(); &#125; &#125;); &#125; @Override public String getUserName() &#123; return mEtUsername.getText().toString(); &#125; @Override public String getPassword() &#123; return mEtPassword.getText().toString(); &#125; @Override public void clearUserName() &#123; mEtUsername.setText(""); &#125; @Override public void clearPassword() &#123; mEtPassword.setText(""); &#125; @Override public void showLoading() &#123; mPbLoading.setVisibility(View.VISIBLE); &#125; @Override public void hideLoading() &#123; mPbLoading.setVisibility(View.GONE); &#125; @Override public void toMainActivity(User user) &#123; Toast.makeText(this, user.getUsername() + " login success , to MainActivity", Toast.LENGTH_SHORT).show(); &#125; @Override public void showFailedError() &#123; Toast.makeText(this, "login failed", Toast.LENGTH_SHORT).show(); &#125;&#125; Presenter 层Presenter 的作用就是从 View 层获取用户的输入，传递到 Model 层进行处理，然后回调给 View 层，输出给用户。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class UserLoginPresenter&#123; private IUserBiz userBiz; private IUserLoginView userLoginView; private Handler mHandler = new Handler();//Presenter必须要能拿到View和Model的实现类 public UserLoginPresenter(IUserLoginView userLoginView) &#123; this.userLoginView = userLoginView; this.userBiz = new UserBiz(); &#125; public void login() &#123; userLoginView.showLoading(); userBiz.login(userLoginView.getUserName(), userLoginView.getPassword(), new OnLoginListener() &#123; @Override public void loginSuccess(final User user) &#123; //需要在UI线程执行 mHandler.post(new Runnable() &#123; @Override public void run() &#123; userLoginView.toMainActivity(user); userLoginView.hideLoading(); &#125; &#125;); &#125; @Override public void loginFailed() &#123; //需要在UI线程执行 mHandler.post(new Runnable() &#123; @Override public void run() &#123; userLoginView.showFailedError(); userLoginView.hideLoading(); &#125; &#125;); &#125; &#125;); &#125; public void clear() &#123; userLoginView.clearUserName(); userLoginView.clearPassword(); &#125;&#125; MVP 成功解决了 MVC 的第一个缺点，但是逻辑处理还是杂糅在 Activity。MVC 到 MVP 简单说，就是增加了一个接口降低一层耦合。但这样会因为在 presenter 中持有 View 接口的引用导致了 Activity 的内存泄露，解决方法可以用如下办法： 在 presenter 中声明一个 onDestroy()方法，在这个方法中将 View 接口对象置为 null，然后在 presenter 中凡是使用到 View 接口的地方，都判断一下是否为空。 在 activity 的 onDestroy() 方法中调用 presenter.onDestroy()，同时也将 activity 持有的 presenter 置空。 MVVM MVVM(Model-View-ViewModel)：MVVM 和 MVP 的区别其实不大，只不过是把 presenter 层换成了 ViewModel 层。它采用的是数据绑定（data-binding）方式，而且是双向绑定：View 绑定到 ViewModel，然后执行一些命令在向它请求一个动作。而反过来，ViewModel 跟 Model通讯，告诉它更新来响应 UI。 常见的构建原则 关注点分离：一个常见的错误是在 Activity 和 Fragment 中编写所有的代码。任何和 UI 或者操作系统交互无关的代码都尽量不要出现在这些类中，尽量保持这些类的精简会帮助你避免很多和生命周期相关的问题。最好减少对它们的依赖以提供一个稳定的用户体验。 通过 Model 驱动 UI，最好是持久化的 Model。最好使用持久化的数据有两个原因：a. 如果系统销毁应用释放资源，用户也不用担心丢失数据； b. 即使网络连接不可靠或者断网，应用仍将继续运行。Model 是负责处理应用数据的组件，Model 独立运行于应用中的 View 和应用程序中的其他组件，因此 Model 和其他应用程序组件的生命周期无关。基于 Model 构建的应用程序，其管理数据的职责明确，所以更容易测试，而且稳定性更高。 Architecture Components 带来的 MVVM 架构Architecture Components 包含了一系列的组件，这些组件能帮助你设计出稳健的，可测试的，架构清晰的 app。 Lifecycle：它是一个持有 Activity/Fragment 生命周期状态信息的类，并且允许其他对象观察此状态。 LiveData：一个数据持有类，持有数据并且这个数据可以被观察被监听，和其他 Observer 不同的是，它是和 Lifecycle 是绑定的，在生命周期内使用有效，减少内存泄露和引用问题。 ViewModel：用于管理数据，它持有 LiveData。处理数据持久化、存取等具体逻辑，相当于 MVP 中的 Presenter。同时是与 Lifecycle 绑定的，使用者无需担心生命周期。 Room：Google 推出的一个 Sqlite ORM 库，使用注解，极大简化数据库的操作。 Paging：分批加载，能够从指定数据源分批加载数据，能配合PagedListAdapter、RecylerView 实现分页加载，并且实现了 ==diff机制==，能够局部更新。 快速了解 创建一个 ViewModel，持有一个 LiveData 12345678910111213141516public class MyViewModel extends ViewModel &#123; // 创建可变LiveData private MutableLiveData&lt;UserDTO&gt; mUserDTO; public MutableLiveData&lt;String&gt; getCurrentUser() &#123; if (mUserDTO == null) &#123; mUserDTO = loadData() &#125; return mUserDTO; &#125; // 获取数据 private MutableLiveData&lt;UserDTO&gt; loadData()&#123;&#125; &#125; 使用 ViewModel，观察其持有的 LiveData 123456789101112131415161718192021222324public class NameActivity extends AppCompatActivity &#123; private NameViewModel mModel; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 获取ViewModel，绑定当前的activity的生命周期 mModel = ViewModelProviders.of(this).get(MyViewModel.class); //创建观察者 final Observer&lt;UserDTO&gt; userObserver = new Observer&lt;UserDTO&gt;() &#123; @Override public void onChanged(@Nullable final UserDTO user) &#123; // 更新UI mNameTextView.setText(user.TrueName); &#125; &#125;; // 绑定观察者,和当前activity的生命周期 mModel.getCurrentUser().observe(this, userObserver); &#125;&#125; ​ 详解 Lifecycle、LiveData、ViewModelLifecycleLifecycle 主要包含三个部分： Lifecycle抽象类：这个类持有了 activity、fragment 等组件的生命周期状态，是一个被观察的对象，拥有addObserver和removeObserver等方法。 LifecycleOwner接口：接口的实现者默认持有一个 Lifecycle，外接可以调用getLifecycle获取到它持有的 Lifecycle 对象。API 26以后，SupportActivity、fragment 等组默认实现了该接口。 LifecycleObserver接口：Lifecycle 的观察者，没有任何方法，主要依靠@OnLifecycleEvent起效果。 12345678910111213public class MyObserver implements LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public void connectListener() &#123; ... &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) public void disconnectListener() &#123; ... &#125;&#125;myActivity.getLifecycle().addObserver(new MyObserver()); MyObserver组件的方法会随着 myActivity 的各种生命而得到调用了。Lifecycle 是 LiveData 和 ViewModel 的基础。 LiveDataLiveData 简单来说就是一个可以根据观察者自身生命周期，在观察者需要结束时自动解绑的 Observable，并且结合了 DataBingding 的特点，LiveData 自身数据改变时可以通知所有的观察者对象。 LiveData 是 一个 abstract 类，有3个关键方法： onActive：LiveData 注册的观察者数量从 0 到 1时会执行，相当于初始化方法 onInactive：LiveData 注册的观察者数量回到 0 时会执行 setValue：数据改变通知所有观察者 12345678910111213141516public class MyLiveData extends LiveData&lt;MyData&gt; &#123; public MyLiveData(Context context) &#123; // Initialize service &#125; @Override protected void onActive() &#123; // Start listening &#125; @Override protected void onInactive() &#123; // Stop listening &#125;&#125; LiveData 和观察者之间是一个双向绑定的过程，实际上，当观察者（LifecycleOwner）注册到 LiveData 的时候，LiveData 也会在内部初始化一个 LifecycleObserver去观察它的观察者。 123456789101112131415161718192021//LiveData的添加观察者的方法public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) &#123; if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // ignore return; &#125; //LiveData会初始化一个LifecycleObserver去观察它的观察者 LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); LifecycleBoundObserver existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; existing.owner != wrapper.owner) &#123; throw new IllegalArgumentException("Cannot add the same observer" + " with different lifecycles"); &#125; if (existing != null) &#123; return; &#125; owner.getLifecycle().addObserver(wrapper);&#125; ViewModelViewModel 是用来存储和管理 UI 相关的数据，这样在配置发生变化（例如：屏幕旋转）时，数据就不会丢失。注意在 ViewModel 内部不应该持有外部 View 的引用，它的生命周期比 Activity/Fragment 都长，引用就会造成内存泄露。 ViewModel 之所以能在 Activity/Fragment 重建的时候依旧能保持，主要是通过ViewModelProviders创建ViewModel，而不是 new 一个 ViewModel。 12// 获取ViewModel，绑定当前的activity的生命周期mModel = ViewModelProviders.of(this).get(MyViewModel.class); ViewModelProviders通过ViewModelStore来管理 ViewModel，ViewModelStore的一个 map 容器存储 ViewModel，通过 Activity 作为 key 区分，假设是同一个 Activity (哪怕不是同一个对象)，就返回同一个 ViewModel，直到 Activity 销毁则移除。 ViewModel 使用场景 用来保存 UI 的数据，比传统方式会有一些优势。 在同一个 actitivity 的多个 Fragment 之间共享数据。 ViewModel vs SavedInstanceState ViewModels 提供了一种在配置更改时保存数据的简便方式，但是如果应用进程被操作系统杀死，那么数据则没有机会被恢复。 通过 SavedInstanceState 保存的数据，存在于操作系统进程的内存中。当用户离开应用数个小时之后，应用的进程很有可能被操作系统杀死，通过 SavedInstanceState 保存的数据，则可以在 Activity 或者 Fragment 重新创建的时候，在其中的 onCreate() 方法中通过 Bundle 恢复数据。 MVVM 优势 数据驱动 支持 MVVM 的人都会养成一个概念，View 是由给与它的数据决定的，View 的变化也应该是数据的变化引起的。 断开引用 ViewModel 不需要关心 View 是怎么样的，不需要调用 View 的方法，因此也不需要再持有 View 接口的引用，这种架构更方便重构、也不需要再从 Presenter 抽出一个个 Logic，可以直接针对 ViewModel 写单元测试。 ViewModel 重用性更好 ViewModel 相当于一个高内聚的数据获取器，不再局限于于被哪个 View 使用，因此它的可用性更好，界面 A 可以用，界面 B 也可以用。 更少的代码 MVVM 一般会由框架层实现数据和 View 的双向绑定，因此代码会更加精简。]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>library</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Binding 的双向绑定]]></title>
    <url>%2F2018%2F04%2F05%2FData%20Binding%20%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[DataBinding 支持双向绑定，能大大减少绑定 app 逻辑与 layout 文件的“胶水代码”。双向绑定，指的是将数据与界面绑定起来，当数据发生变化时会体现在界面上，反过来界面内容变化也会同步更新到数据上，使用 DataBinding 能轻松实现 MVVM 模式。 初始化绑定在初始化时我们会调用下面的代码： 12ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);binding.setUser(user); 进入setUser： 123456789public void setUser(User User) &#123; this.mUser = User; synchronized(this) &#123; this.mDirtyFlags |= 2L; &#125; this.notifyPropertyChanged(1); super.requestRebind();&#125; mDirtyFlags用于表示哪个属性发生变化，notifyPropertyChanged(1)实则为notifyPropertyChanged(BR.user)，顾名思义，是发出 user 数据变化的通知。看看requestRebind是干什么的： 1234567891011121314151617protected void requestRebind() &#123; if (mContainingBinding != null) &#123; mContainingBinding.requestRebind(); &#125; else &#123; synchronized (this) &#123; if (mPendingRebind) &#123; return; &#125; mPendingRebind = true; &#125; if (USE_CHOREOGRAPHER) &#123; mChoreographer.postFrameCallback(mFrameCallback); &#125; else &#123; mUIThreadHandler.post(mRebindRunnable); &#125; &#125;&#125; 这里根据 api 版本做了点不同的处理，API 16及以上的，会往mChoreographer发一个mFrameCallback；否则直接往 UI 线程发一个mRebindRunnable。其实这里俩个分支的结果基本一致，mChoreographer会在界面刷新时执行mRebindRunnable。 123456789101112131415161718192021private final Runnable mRebindRunnable = new Runnable() &#123; @Override public void run() &#123; synchronized (this) &#123; mPendingRebind = false; &#125; processReferenceQueue(); if (VERSION.SDK_INT &gt;= VERSION_CODES.KITKAT) &#123; // Nested so that we don't get a lint warning in IntelliJ if (!mRoot.isAttachedToWindow()) &#123; // Don't execute the pending bindings until the View // is attached again. mRoot.removeOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER); mRoot.addOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER); return; &#125; &#125; executePendingBindings(); &#125;&#125;; 最终都会执行executePendingBindings()，继而调用executeBindingsInternal()方法。 1234567891011121314151617181920212223242526private void executeBindingsInternal() &#123; if (mIsExecutingPendingBindings) &#123; requestRebind(); return; &#125; if (!hasPendingBindings()) &#123; return; &#125; mIsExecutingPendingBindings = true; mRebindHalted = false; if (mRebindCallbacks != null) &#123; mRebindCallbacks.notifyCallbacks(this, REBIND, null); // The onRebindListeners will change mPendingHalted if (mRebindHalted) &#123; mRebindCallbacks.notifyCallbacks(this, HALTED, null); &#125; &#125; if (!mRebindHalted) &#123; executeBindings(); if (mRebindCallbacks != null) &#123; mRebindCallbacks.notifyCallbacks(this, REBOUND, null); &#125; &#125; mIsExecutingPendingBindings = false;&#125; executeBindings是一个抽象的方法，具体实现在编译时生成的ActivityMainBinding里。 12345678910111213141516171819202122232425262728293031@Overrideprotected void executeBindings() &#123; long dirtyFlags = 0; synchronized(this) &#123; dirtyFlags = mDirtyFlags; mDirtyFlags = 0; &#125; android.databinding.ObservableField&lt;java.lang.String&gt; userName = null; java.lang.String userNameGet = null; com.example.databindingdemo.User user = mUser; if ((dirtyFlags &amp; 0x7L) != 0) &#123; if (user != null) &#123; // read user.name userName = user.getName(); &#125; updateRegistration(0, userName); if (userName != null) &#123; // read user.name.get() userNameGet = userName.get(); &#125; &#125; // batch finished if ((dirtyFlags &amp; 0x7L) != 0) &#123; // api target 1 android.databinding.adapters.TextViewBindingAdapter.setText(this.button, userNameGet); &#125;&#125; 这里面的代码比较简单，除了对界面进行赋值，还调用了updateRegistration方法。 123protected boolean updateRegistration(int localFieldId, Observable observable) &#123; return updateRegistration(localFieldId, observable, CREATE_PROPERTY_LISTENER);&#125; updateRegistration第三个参数传了CREATE_PROPERTY_LISTENER。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private static final CreateWeakListener CREATE_PROPERTY_LISTENER = new CreateWeakListener() &#123; @Override public WeakListener create(ViewDataBinding viewDataBinding, int localFieldId) &#123; return new WeakPropertyListener(viewDataBinding, localFieldId).getListener(); &#125;&#125;;private static class WeakPropertyListener extends Observable.OnPropertyChangedCallback implements ObservableReference&lt;Observable&gt; &#123; final WeakListener&lt;Observable&gt; mListener; public WeakPropertyListener(ViewDataBinding binder, int localFieldId) &#123; mListener = new WeakListener&lt;Observable&gt;(binder, localFieldId, this); &#125; // …… @Override public void onPropertyChanged(Observable sender, int propertyId) &#123; ViewDataBinding binder = mListener.getBinder(); if (binder == null) &#123; return; &#125; Observable obj = mListener.getTarget(); if (obj != sender) &#123; return; // notification from the wrong object? &#125; binder.handleFieldChange(mListener.mLocalFieldId, sender, propertyId); &#125;&#125;private static class WeakListener&lt;T&gt; extends WeakReference&lt;ViewDataBinding&gt; &#123; private final ObservableReference&lt;T&gt; mObservable; protected final int mLocalFieldId; private T mTarget; public WeakListener(ViewDataBinding binder, int localFieldId, ObservableReference&lt;T&gt; observable) &#123; super(binder, sReferenceQueue); mLocalFieldId = localFieldId; mObservable = observable; &#125; // …… &#125; 从上面知道CREATE_PROPERTY_LISTENER是一个CreateWeakListener对象，CreateWeakListener.create()能得到WeakPropertyListener，WeakPropertyListener内有变量WeakListener，WeakListener持有ViewDataBinding以及Observable。再看看updateRegistration方法。 1234567891011121314151617private boolean updateRegistration(int localFieldId, Object observable, CreateWeakListener listenerCreator) &#123; if (observable == null) &#123; return unregisterFrom(localFieldId); &#125; WeakListener listener = mLocalFieldObservers[localFieldId]; if (listener == null) &#123; registerTo(localFieldId, observable, listenerCreator); return true; &#125; if (listener.getTarget() == observable) &#123; return false;//nothing to do, same object &#125; unregisterFrom(localFieldId); registerTo(localFieldId, observable, listenerCreator); return true;&#125; 123456789101112protected void registerTo(int localFieldId, Object observable, CreateWeakListener listenerCreator) &#123; if (observable == null) &#123; return; &#125; WeakListener listener = mLocalFieldObservers[localFieldId]; if (listener == null) &#123; listener = listenerCreator.create(this, localFieldId); mLocalFieldObservers[localFieldId] = listener; &#125; listener.setTarget(observable);&#125; registerTo把CreateWeakListener存储在mLocalFieldObservers里面。 这样一来 View 和 VM 的联系就通过ViewDatabinding建立起来了。View 内有ViewDatabinding，而ViewDatabinding里持有各个 View 的引用。ViewDataBinding有 VM 的变量，而 VM 内的PropertyChangeRegistry监听实则为WeakPropertyListener，WeakListener能获取到ViewDatabinding。 VM 变化如何通知 View要达到 VM 变化时自动绑定到 View 上，有下面俩种方式： 继承自 BaseObservable，在 getter 上增加@Bindable注解，在 setter 里增加代码notifyPropertyChanged(BR.xxx)。 无需继承，需要将属性替换为 Observable 类，例如ObservableInt、ObservableField等。 这两种本质上都是一样的。在第二种方式中，当属性发生变化时，会调用notifyChange，而notifyChange与notifyPropertyChanged做的事情都是一样的，都是调用mCallbacks.notifyCallbacks去通知。 1234567891011121314151617public void notifyChange() &#123; synchronized (this) &#123; if (mCallbacks == null) &#123; return; &#125; &#125; mCallbacks.notifyCallbacks(this, 0, null);&#125;public void notifyPropertyChanged(int fieldId) &#123; synchronized (this) &#123; if (mCallbacks == null) &#123; return; &#125; &#125; mCallbacks.notifyCallbacks(this, fieldId, null);&#125; View 的变化如何同步到 VMDataBinding 在旧版本中是不支持这个功能的，后来才完善了这个功能。 1android:text="@=&#123;user.name&#125;" 在使用双向绑定后，可以发现在executeBindings里多了一点代码： 12345678@Overrideprotected void executeBindings() &#123; // …… if ((dirtyFlags &amp; 0x4L) != 0) &#123; // api target 1 android.databinding.adapters.TextViewBindingAdapter.setTextWatcher(this.button, (android.databinding.adapters.TextViewBindingAdapter.BeforeTextChanged)null, (android.databinding.adapters.TextViewBindingAdapter.OnTextChanged)null, (android.databinding.adapters.TextViewBindingAdapter.AfterTextChanged)null, buttonandroidTextAttrChanged); &#125;&#125; 在这个方法里调用了setTextWatcher去监听 Button 的TextWatcher。 12345678910111213141516171819202122232425@BindingAdapter(value = &#123;"android:beforeTextChanged", "android:onTextChanged", "android:afterTextChanged", "android:textAttrChanged"&#125;, requireAll = false)public static void setTextWatcher(TextView view, final BeforeTextChanged before, final OnTextChanged on, final AfterTextChanged after, final InverseBindingListener textAttrChanged) &#123; final TextWatcher newValue; if (before == null &amp;&amp; after == null &amp;&amp; on == null &amp;&amp; textAttrChanged == null) &#123; newValue = null; &#125; else &#123; newValue = new TextWatcher() &#123; // …… @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; if (textAttrChanged != null) &#123; textAttrChanged.onChange(); &#125; &#125; // …... &#125;; &#125; // …... if (newValue != null) &#123; view.addTextChangedListener(newValue); &#125;&#125; 当 View 发生变化时，会调textAttrChanged的onChange方法。 12345678910111213141516171819202122232425262728293031// Inverse Binding Event Handlersprivate android.databinding.InverseBindingListener buttonandroidTextAttrChanged = new android.databinding.InverseBindingListener() &#123; @Override public void onChange() &#123; // Inverse of user.name.get() // is user.name.set((java.lang.String) callbackArg_0) java.lang.String callbackArg_0 = android.databinding.adapters.TextViewBindingAdapter.getTextString(button); // localize variables for thread safety // user.name android.databinding.ObservableField&lt;java.lang.String&gt; userName = null; // user.name != null boolean userNameJavaLangObjectNull = false; // user != null boolean userJavaLangObjectNull = false; // user com.example.databindingdemo.User user = mUser; // user.name.get() java.lang.String userNameGet = null; userJavaLangObjectNull = (user) != (null); if (userJavaLangObjectNull) &#123; userName = user.getName(); userNameJavaLangObjectNull = (userName) != (null); if (userNameJavaLangObjectNull) &#123; userName.set(((java.lang.String) (callbackArg_0))); &#125; &#125; &#125;&#125;; 在onChange回调里，将变动后的值赋值到 VM 上。这样，View 的变化就自动同步到 VM 上了。 双向绑定的问题及解决方式 死循环绑定：因为数据源改变会通知 View 刷新，而 View 改变又会通知数据源刷新，这样一直循环往复，就形成了死循环绑定。 解决方法：在处理双向绑定的业务逻辑时，要对新旧数据进行比较，只处理新旧数据不一样的数据，对于新旧数据一样的数据作 return 处理，通过这种方式来避免死循环绑定。 数据源中的数据有时需要经过转换才能在 View 中展示，而 View 中展示的内容也需要经过转换才能绑定到对应的数据源上。 解决方法：使用@InverseMethod定义转换方法，在布局文件中使用。]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌套滑动机制]]></title>
    <url>%2F2018%2F04%2F05%2F%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[嵌套滑动一直是 Android 中比较棘手的问题，根本原因是 Android 的事件分发机制导致的。不过这个问题终于在 API 21之后有了官方的解决方法，就是嵌套滑动机制。 基本原理嵌套滑动的基本原理是在子控件接收到滑动一段距离的请求时，先询问父控件是否要滑动，如果滑动了父控件就通知子控件它消耗了一部分滑动距离，子控件就只处理剩下的滑动距离，然后子控件滑动完毕后再把剩余的滑动距离传给父控件。 具体实现API 21之后 嵌套滑动的相关逻辑作为普通方法直接写进了最新的（API 21之后）View和ViewGroup类。 向前兼容 官方在android.support.v4兼容包中提供了两个接口NestedScrollingChild和NestedScrollingParent。两个接口分别定义上面提到的View和ViewParent新增的普通方法。 辅助类 除了接口兼容包还提供了NestedScrollingChildHelper和NestedScrollingParentHelper两个辅助类，这两个辅助类实际上就是对应View和ViewParent中新增的普通方法。 相关方法NestedScrollingChild 内控件是嵌套滑动的发起者。 startNestedScroll：起始方法，主要作用是找到接收滑动距离信息的外控件。 dispatchNestedPreScroll：在内控件处理滑动前把滑动信息分发给外控件。 dispatchNestedScroll：在内控件处理完滑动后把剩下的滑动距离信息分发给外控件。 stopNestedScroll：结束方法，主要作用就是清空嵌套滑动的相关状态。 setNestedScrollingEnabled和isNestedScrollingEnabled：一对 get&amp;set 方法，用来判断控件是否支持嵌套滑动。 dispatchNestedPreFling和dispatchNestedFling：跟 Scroll 的对应方法作用类似，不过分发的不是滑动信息而是 Fling 信息。 NestedScrollingParent 外控件通过onNestedPreScroll和onNestedScroll来接收内控件响应滑动前后的滑动距离信息。 onStartNestedScroll：对应startNestedScroll，内控件通过调用外控件的这个方法来确定外控件是否接收滑动信息。 onNestedScrollAccepted：当外控件确定接收滑动信息后该方法被回调，可以让外控件针对嵌套滑动做一些前期工作。 onNestedPreScroll：关键方法，接收内控件处理滑动前的滑动距离信息，在这里外控件可以优先响应滑动操作，消耗部分或者全部滑动距离。 onNestedScroll：关键方法，接收内控件处理完滑动后的滑动距离信息，在这里外控件可以选择是否处理剩余的滑动距离。 onStopNestedScroll：对应stopNestedScroll，用来做一些收尾工作。 getNestedScrollAxes：返回嵌套滑动的方向，区分横向滑动和竖向滑动，作用不大。 onNestedPreFling和onNestedFling：同上略。 从 NestedScrollView 看嵌套机制接下来通过分析相对简单的支持嵌套滑动的容器NestedScrollView，来了解下怎样主动调起嵌套滑动的方法，以及嵌套滑动的具体逻辑。NestedScrollView简单地说就是支持嵌套滑动的ScrollView，内部逻辑简单，而且它既可以是内控件，也可以是外控件，所以选择分析它来了解嵌套滑动机制。 嵌套滑动是从startNestedScroll方法开始的，从源码中我们可以发现在两个地方调用了这个方法： onInterceptTouchEvent中ACTION_DOWN的情况 onTouchEvent中ACTION_DOWN的情况 因为ACTION_DOWN是滑动操作的开始事件，所以当接收到这个事件的时候尝试找对应的外控件。只有找到了外控件才有后续的嵌套滑动的逻辑发生。 接着我们看startNestedScroll是如何找对应的外控件的，因为NestedScrollView#startNestedScroll调用了辅助方法的startNestedScroll，所以下面直接看View#startNestedScroll。 12345678910111213141516171819202122232425// View.javapublic boolean startNestedScroll(int axes) &#123; // ... if (isNestedScrollingEnabled()) &#123; ViewParent p = getParent(); View child = this; while (p != null) &#123; try &#123; // 关键代码 if (p.onStartNestedScroll(child, this, axes)) &#123; mNestedScrollingParent = p; p.onNestedScrollAccepted(child, this, axes); return true; &#125; &#125; catch (AbstractMethodError e) &#123; // ... &#125; if (p instanceof View) &#123; child = (View) p; &#125; p = p.getParent(); &#125; &#125; return false;&#125; 遍历父控件，调用父控件的onStartNestedScroll，返回 true 表示找到了对应的外控件，找到外控件后马上调用onNestedScrollAccepted。所以可以知道： 外控件不一定是内控件的直接父控件，但一定是最近的符合条件的外控件。 关于onStartNestedScroll的方法说明，返回 true 表示接收内控件的滑动信息。对于NestedScrollView#onStartNestedScroll内部逻辑很简单，只要是竖直滑动方向就返回 true。所以可以知道： NestedScrollView不支持横向嵌套滑动。 接着看NestedScrollView#onNestedScrollAccepted。 1234@Overridepublic void onNestedScrollAccepted(View child, View target, int nestedScrollAxes) &#123; mParentHelper.onNestedScrollAccepted(child, target, nestedScrollAxes); startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL);&#125; 辅助类的方法很简单，就是记录当前的滑动方向，在这里NestedScrollView又调用startNestedScroll来找它自己的外控件，这是为了连续嵌套NestedScrollView。 找到了外控件后ACTION_DOWN事件就没嵌套滑动的事了，要滑动肯定会在onTouchEvent中处理ACTION_MOVE事件。 123456789101112131415161718192021222324252627// NestedScrollView#onTouchEventcase MotionEvent.ACTION_MOVE: // ... final int y = (int) MotionEventCompat.getY(ev, activePointerIndex); int deltaY = mLastMotionY - y; // 让外控件先处理滑动距离 if (dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)) &#123; deltaY -= mScrollConsumed[1];// 消耗滑动距离 // ... &#125; // ... if (mIsBeingDragged) &#123; // ... // 内控件处理滑动距离 if (overScrollByCompat(0, deltaY, 0, getScrollY(), 0, range, 0, 0, true) &amp;&amp; !hasNestedScrollingParent()) &#123; // ... &#125; final int scrolledDeltaY = getScrollY() - oldY; final int unconsumedY = deltaY - scrolledDeltaY; if (dispatchNestedScroll(0, scrolledDeltaY, 0, unconsumedY, mScrollOffset)) &#123; // ... &#125; // ... &#125; break; 先计算出本次滑动距离deltaY，得到滑动距离deltaY后，先把它传给dispatchNestedPreScroll，然后在结果返回 true 的时候， delta会减去mScrollConsumed[1]。 12345678910// View.javapublic boolean dispatchNestedPreScroll(int dx, int dy, @Nullable @Size(2) int[] consumed, @Nullable @Size(2) int[] offsetInWindow) &#123; // ... 忽略状态判断 consumed[0] = 0; consumed[1] = 0; mNestedScrollingParent.onNestedPreScroll(this, dx, dy, consumed); return consumed[0] != 0 || consumed[1] != 0; // 其他情况返回false&#125; dispatchNestedPreScroll的工作就是把滑动距离在内控件处理前分发给外控件，所以这里的关键代码也很简单，就是直接把相关的参数传给外控件的onNestedPreScroll，然后只要外控件消耗了滑动距离（不论横向还是竖向），就会返回 true。 外控件如果想在内控件之前消耗滑动距离仅需要在onNestedPreScroll把消耗的值放到数组中返回给内控件。 onNestedPreScroll是决定外控件的嵌套滑动逻辑的关键方法，在不同的控件中应该是根据需要有不同的实现的，而在NestedScrollView中就是直接询问它自己的外控件是否消耗滑动距离。在我们自己修改嵌套滑动逻辑的时候需要注意滑动距离的正负号和内控件处理consumed数组的方式。 现在外控件已经比内控件先处理了滑动距离了，如果外控件没有完全消耗掉所有滑动距离，这时该内控件处理剩下的滑动距离了。 在NestedScrollView中通过NestedScrollView#overScrollByCompat来进行滑动，并且滑动结束后通过比对滑动前后的scrollY值得到了内控件消耗的滑动距离，然后得到剩下的滑动距离，最后传给dispatchNestedScroll。 dispatchNestedScroll的逻辑跟dispatchNestedPreScroll几乎一样，区别是它调用了外控件的onNestedScroll。因为到这里已经是处理滑动距离最后的机会了，所以onNestedScroll不会再影响内控件的处理逻辑，ACTION_MOVE事件就分析完毕了。 最后就是stopNestedScroll了，调用这个方法基本是新的滑动操作开始前，或者滑动操作结束/取消，代码逻辑就是进行一些变量的重置工作和调用onStopNestedScroll，而onStopNestedScroll也类似。 NestedScrollView的嵌套滑动逻辑基本就是这样，它代表了嵌套滑动的”约定”处理方式，虽然不同的控件实际的实现会有不同，不过应该遵循基本方法的调用顺序，确保参数的含义和参数的处理方式。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>source code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AspectJ]]></title>
    <url>%2F2018%2F04%2F03%2FAspectJ%2F</url>
    <content type="text"><![CDATA[如果说，OOP 如果是把问题划分到单个模块的话，那么 AOP 就是把涉及到众多模块的某一类问题进行统一管理。这里通过几个小例子，讲解在 Android 开发中，如何运用 AOP 的方式，进行全局切片管理，达到简洁优雅，一劳永逸的效果。 SingleClickAspect，防止 View 被连续点击出发多次事件给点击事件加一个切入点，添加一个注解 1234@Retention(RetentionPolicy.CLASS)@Target(ElementType.METHOD)public @interface SingleClick &#123;&#125; 然后编写我们的 Aspect 类 1234567891011121314151617181920212223242526272829303132333435@Aspectpublic class SingleClickAspect &#123; public static final String TAG="SingleClickAspect"; public static final int MIN_CLICK_DELAY_TIME = 600; static int TIME_TAG = R.id.click_time; @Pointcut("execution(@com.ditclear.app.aop.annotation.SingleClick * *(..))")//方法切入点 public void methodAnnotated()&#123; &#125; @Around("methodAnnotated()")//在连接点进行方法替换 public void aroundJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable&#123; View view=null; for (Object arg: joinPoint.getArgs()) &#123; if (arg instanceof View) view= ((View) arg); &#125; if (view!=null)&#123; Object tag=view.getTag(TIME_TAG); long lastClickTime= (tag!=null)? (long) tag :0; if (BuildConfig.DEBUG) &#123; Log.d(TAG, "lastClickTime:" + lastClickTime); &#125; long currentTime = Calendar.getInstance().getTimeInMillis(); if (currentTime - lastClickTime &gt; MIN_CLICK_DELAY_TIME) &#123;//过滤掉600毫秒内的连续点击 view.setTag(TIME_TAG, currentTime); if (BuildConfig.DEBUG) &#123; Log.d(TAG, "currentTime:" + currentTime); &#125; joinPoint.proceed();//执行原方法 &#125; &#125; &#125;&#125; 接下来是使用 123@SingleClickpublic void onClick(View view) &#123;&#125; CheckLoginAspect 拦截未登录用户的权限12345678910111213141516171819202122@Aspectpublic class CheckLoginAspect &#123; @Pointcut("execution(@com.app.annotation.aspect.CheckLogin * *(..))")//方法切入点 public void methodAnnotated() &#123; &#125; @Around("methodAnnotated()")//在连接点进行方法替换 public void aroundJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable &#123; if (null == SpUtil.getUser()) &#123; Snackbar.make(App.getAppContext().getCurActivity().getWindow().getDecorView(), "请先登录!", Snackbar.LENGTH_LONG) .setAction("登录", new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; TRouter.go(C.LOGIN); &#125; &#125;).show(); return; &#125; joinPoint.proceed();//执行原方法 &#125;&#125; 使用方法: 123456789101112131415161718192021222324public class AdvisePresenter extends AdviseContract.Presenter &#123; @CheckLogin public void createMessage(String msg) &#123; _User user = SpUtil.getUser(); ApiFactory.createMessage( new Message(ApiUtil.getPointer( new _User(C.ADMIN_ID)), msg, ApiUtil.getPointer(user), user.objectId)) .subscribe( res -&gt; mView.sendSuc(), e -&gt; mView.showMsg("消息发送失败!")); &#125; @CheckLogin public void initAdapterPresenter(AdapterPresenter mAdapterPresenter) &#123; mAdapterPresenter .setRepository(ApiFactory::getMessageList) .setParam(C.INCLUDE, C.CREATER) .setParam(C.UID, SpUtil.getUser().objectId) .fetch(); &#125;&#125; MemoryCacheAspect 内存缓存切片12345678910111213141516171819202122232425262728293031@Aspectpublic class MemoryCacheAspect &#123; @Pointcut("execution(@com.app.annotation.aspect.MemoryCache * *(..))")//方法切入点 public void methodAnnotated() &#123; &#125; @Around("methodAnnotated()")//在连接点进行方法替换 public Object aroundJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable &#123; MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); String methodName = methodSignature.getName(); MemoryCacheManager mMemoryCacheManager = MemoryCacheManager.getInstance(); StringBuilder keyBuilder = new StringBuilder(); keyBuilder.append(methodName); for (Object obj : joinPoint.getArgs()) &#123; if (obj instanceof String) keyBuilder.append((String) obj); else if (obj instanceof Class) keyBuilder.append(((Class) obj).getSimpleName()); &#125; String key = keyBuilder.toString(); Object result = mMemoryCacheManager.get(key);//key规则 ： 方法名＋参数1+参数2+... LogUtils.showLog("MemoryCache", "key：" + key + "---&gt;" + (result != null ? "not null" : "null")); if (result != null) return result;//缓存已有，直接返回 result = joinPoint.proceed();//执行原方法 if (result instanceof List &amp;&amp; result != null &amp;&amp; ((List) result).size() &gt; 0 //列表不为空 || result instanceof String &amp;&amp; !TextUtils.isEmpty((String) result)//字符不为空 || result instanceof Object &amp;&amp; result != null)//对象不为空 mMemoryCacheManager.add(key, result);//存入缓存 LogUtils.showLog("MemoryCache", "key：" + key + "---&gt;" + "save"); return result; &#125;&#125; 看看 Apt 生成的 Factory： 123456789101112131415public final class InstanceFactory &#123; /** * @此方法由apt自动生成 */ @MemoryCache public static Object create(Class mClass) throws IllegalAccessException, InstantiationException &#123; switch (mClass.getSimpleName()) &#123; case "AdvisePresenter": return new AdvisePresenter(); case "ArticlePresenter": return new ArticlePresenter(); case "HomePresenter": return new HomePresenter(); case "LoginPresenter": return new LoginPresenter(); case "UserPresenter": return new UserPresenter(); default: return mClass.newInstance(); &#125; &#125;&#125; TimeLogAspect 自动打印方法的耗时123456789101112131415161718192021222324252627282930@Aspectpublic class TimeLogAspect &#123; @Pointcut("execution(@com.app.annotation.aspect.TimeLog * *(..))")//方法切入点 public void methodAnnotated() &#123; &#125; @Pointcut("execution(@com.app.annotation.aspect.TimeLog *.new(..))")//构造器切入点 public void constructorAnnotated() &#123; &#125; @Around("methodAnnotated() || constructorAnnotated()")//在连接点进行方法替换 public Object aroundJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable &#123; MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); LogUtils.showLog("TimeLog getDeclaringClass", methodSignature.getMethod().getDeclaringClass().getCanonicalName()); String className = methodSignature.getDeclaringType().getSimpleName(); String methodName = methodSignature.getName(); long startTime = System.nanoTime(); Object result = joinPoint.proceed();//执行原方法 StringBuilder keyBuilder = new StringBuilder(); keyBuilder.append(methodName + ":"); for (Object obj : joinPoint.getArgs()) &#123; if (obj instanceof String) keyBuilder.append((String) obj); else if (obj instanceof Class) keyBuilder.append(((Class) obj).getSimpleName()); &#125; String key = keyBuilder.toString(); LogUtils.showLog("TimeLog", (className + "." + key + joinPoint.getArgs().toString() + " ---&gt;:" + "[" + (TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) + "ms]"));// 打印时间差 return result; &#125;&#125; 使用方法： 12345678@TimeLogpublic void onCreate() &#123; super.onCreate(); mApp = this; SpUtil.init(this); store = new Stack&lt;&gt;(); registerActivityLifecycleCallbacks(new SwitchBackgroundCallbacks());&#125; SysPermissionAspect 运行时权限申请1234567891011121314151617181920212223242526272829303132333435@Aspectpublic class SysPermissionAspect &#123; @Around("execution(@com.app.annotation.aspect.Permission * *(..)) &amp;&amp; @annotation(permission)") public void aroundJoinPoint(ProceedingJoinPoint joinPoint, Permission permission) throws Throwable &#123; AppCompatActivity ac = (AppCompatActivity) App.getAppContext().getCurActivity(); new AlertDialog.Builder(ac) .setTitle("提示") .setMessage("为了应用可以正常使用，请您点击确认申请权限。") .setNegativeButton("取消", null) .setPositiveButton("允许", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; MPermissionUtils.requestPermissionsResult(ac, 1, permission.value() , new MPermissionUtils.OnPermissionListener() &#123; @Override public void onPermissionGranted() &#123; try &#123; joinPoint.proceed();//获得权限，执行原方法 &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onPermissionDenied() &#123; MPermissionUtils.showTipsDialog(ac); &#125; &#125;); &#125; &#125;) .create() .show(); &#125;&#125; 使用方法： 12345678@Permission(Manifest.permission.CAMERA)public void takePhoto() &#123; startActivityForResult( new Intent(MediaStore.ACTION_IMAGE_CAPTURE) .putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(getExternalCacheDir()+ "user_photo.png"))), C.IMAGE_REQUEST_CODE);&#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AOP</tag>
        <tag>AspectJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android AOP]]></title>
    <url>%2F2018%2F04%2F03%2FAndroid%20AOP%2F</url>
    <content type="text"><![CDATA[Android AOP 就是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，提高开发效率。 Android AOP 之 APT、AspectJ、JavasisstAPT代表框架：DataBinding、Dagger2、ButterKnife、EventBus3、DBFlow、AndroidAnnotation APT(Annotation Processing Tool)定义编译期的注解，再通过继承Proccesor实现代码生成逻辑，实现了编译期生成代码的逻辑。 使用姿势 ： 建立一个 java 的 Module，写一个继承AbstractProcessor的类。 在工具类里处理我们自定义的注解、生成代码。 在 Gradle 中添加dependencies annotationProcessor project(&#39;:apt&#39;)。 AspectJ代表框架： Hugo(Jake Wharton) AspectJ 支持编译期和加载时代码注入，在开始之前，我们先看看需要了解的词汇： Advice（通知）: 典型的 Advice 类型有 before、after 和 around，分别表示在目标方法执行之前、执行后和完全替代目标方法执行的代码。 Joint point（连接点）: 程序中可能作为代码注入目标的特定的点和入口。 Pointcut（切入点）: 告诉代码注入工具，在何处注入一段特定代码的表达式。 Aspect（切面）: Pointcut 和 Advice 的组合看做切面。例如，在本例中通过定义一个 pointcut 和给定恰当的 advice，添加一个了内存缓存的切面。 Weaving（织入）: 注入代码（advices）到目标位置（joint points）的过程。 使用姿势： 建立一个 android lib Module，定义一个切片，处理自定义注解，和添加切片逻辑。 自定义一个 gradle 插件，使用 AspectJ 的编译器（ajc，一个java编译器的扩展)，对所有受 aspect 影响的类进行织入，在 gradle 的编译 task 中增加额外配置，使之能正确编译运行。 在 Gradle 中添加apply plugin:com.app.plugin.AspectjPlugin。 Javassist代表框架：热修复框架 HotFix 、Savior（InstantRun）等 Javassist 作用是在编译器间修改 class 文件，可以让我们直接修改编译后的 class 二进制代码，首先我们得知道什么时候编译完成，并且我们要赶在 class 文件被转化为 dex 文件之前去修改。使用Transform能很方便地实现，Tranfrom一经注册便会自动添加到 Task 执行序列中，并且正好是项目被打包成 dex 之前。 使用姿势： 定义一个 buildSrc module 添加自定义 Plugin。 自定义Transform。 在Transform里处理 Task，通过 inputs 拿到一些东西，处理完毕之后就输出 outputs，而下一个 Task 的 inputs 则是上一个 Task 的 outputs。 使用 Javassist 操作字节码，添加新的逻辑或者修改原有逻辑。 在 Gradle 中添加apply plugin:com.app.plugin.MyPlugin。]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger2]]></title>
    <url>%2F2018%2F04%2F03%2FDagger2%2F</url>
    <content type="text"><![CDATA[Dagger2 是 Dagger 的升级版，是一个依赖注入框架。Dagger2 与其他依赖注入框架不同，它是通过 apt 插件在编译阶段生成相应的注入代码。依赖注入是面向对象编程的一种设计模式，其目的是为了降低程序耦合，这个耦合就是类之间的依赖引起的。 MVP在 mvp 中，最常见的一种依赖关系，就是 Activity 持有 presenter 的引用，并在 Activity 中实例化这个 presenter，即 Activity 依赖 presenter，presenter 又需要依赖 View 接口，从而更新 UI。 12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends AppCompatActivity implements IView &#123; private MainPresenter mainPresenter; ... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //实例化presenter 将view传递给presenter mainPresenter = new MainPresenter(this); //调用Presenter方法加载数据 mainPresenter.loadData(); ... &#125; @Override public void onClearText() &#123; ... &#125;&#125;public class MainPresenter &#123; private IView mView; MainPresenter(IView view) &#123; mView = view; &#125; public void loadData() &#123; //调用model层方法，加载数据 ... //回调方法成功时 mView.updateUI(); &#125;&#125;public interface ILoginView &#123; public void onClearText();&#125; Dagger2 依赖注入的 MVP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class MainActivity extends AppCompatActivity implements IView &#123; @Inject MainPresenter mainPresenter; ... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); DaggerMainComponent.builder() .mainModule(new MainModule(this)) .build() .inject(this); //调用Presenter方法加载数据 mainPresenter.loadData(); ... &#125; @Override public void onClearText() &#123; ... &#125;&#125;public class MainPresenter &#123; private IView; @Inject MainPresenter(IView view) &#123; mView = view; &#125; public void loadData() &#123; //调用model层方法，加载数据 ... //回调方法成功时 mView.updateUI(); &#125;&#125;public interface ILoginView &#123; public void onClearText();&#125;@Modulepublic class MainModule &#123; private final IView mView; public MainModule(IView view) &#123; mView = view; &#125; @Provides MainView provideMainView() &#123; return mView; &#125;&#125;@Component(modules = MainModule.class)public interface MainComponent &#123; void inject(MainActivity activity);&#125; @Inject带有此注解的属性或构造方法将参与到依赖注入中，Dagger2 会实例化有此注解的类 @Module带有此注解的类，用来提供依赖，里面定义一些用@Provides注解的以provide开头的方法，这些方法就是所提供的依赖，Dagger2 会在该类中寻找实例化某个类所需要的依赖。 @Component用来将@Inject和@Module联系起来的桥梁，从@Module中获取依赖并将依赖注入给@Inject。 Dagger2 注入原理先了解类图及辅助类的生成规则： 带@Component注解 ：生成 Dagger_(带@Component注解接口名称)。 带@Module注解 ：生成 (带@Mudule类名)_(带@Provides注解的方法名)Factory。 带@Inject注解：生成 (需要注入对象所在的类名)_MembersInjector。 下面是 Dagger2 生成的注入代码，我们先看 MainPresenter 所对应的注入类。 1234567891011121314151617181920212223242526public class MainPresenter &#123; IView mView; @Inject MainPresenter(IView view) &#123; mView = view; &#125; &#125;public final class MainPresenter_Factory implements Factory&lt;MainPresenter&gt; &#123; private final Provider&lt;IView&gt; viewProvider; public MainPresenter_Factory(Provider&lt;IView&gt; viewProvider) &#123; assert viewProvider != null; this.viewProvider = viewProvider; &#125; @Override public MainPresenter get() &#123; return new MainPresenter(viewProvider.get()); &#125; public static Factory&lt;MainPresenter&gt; create(Provider&lt;IView&gt; viewProvider) &#123; return new MainPresenter_Factory(viewProvider); &#125;&#125; MainModule 所对应的注入类。 123456789101112131415161718192021222324252627282930313233@Modulepublic class MainModule &#123; private final IView mView; public MainModule(IView view) &#123; mView = view; &#125; @Provides IView provideMainView() &#123; return mView; &#125; &#125;public final class MainModule_ProvideMainViewFactory implements Factory&lt;IView&gt; &#123; private final MainModule module; public MainModule_ProvideMainViewFactory(MainModule module) &#123; assert module != null; this.module = module; &#125; @Override public IView get() &#123; return Preconditions.checkNotNull( module.provideMainView(), "Cannot return null from a non-@Nullable @Provides method"); &#125; public static Factory&lt;IView&gt; create(MainModule module) &#123; return new MainModule_ProvideMainViewFactory(module); &#125;&#125; 看到这里我们应该明白了 MainPresenter 的实例化过程。MainPresenter 会对应的有一个工厂类，在这个类的get()方法中进行 MainPresenter 创建，而 MainPresenter 所需要的 View 依赖，是由 MainModule 里定义的以provide开头的方法所对应的工厂类提供的。 MainPresenter 实例和@Inject注解的 MainPresenter 关联是在 Component 里实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Component(modules = MainModule.class)public interface MainComponent &#123; void inject(MainActivity activity);&#125;public final class DaggerMainComponent implements MainComponent &#123; private Provider&lt;IView&gt; provideMainViewProvider; private Provider&lt;MainPresenter&gt; mainPresenterProvider; private MembersInjector&lt;MainActivity&gt; mainActivityMembersInjector; private DaggerMainComponent(Builder builder) &#123; assert builder != null; initialize(builder); &#125; public static Builder builder() &#123; return new Builder(); &#125; @SuppressWarnings("unchecked") private void initialize(final Builder builder) &#123; this.provideMainViewProvider = MainModule_ProvideMainViewFactory.create(builder.mainModule); this.mainPresenterProvider = MainPresenter_Factory.create(provideMainViewProvider); this.mainActivityMembersInjector = MainActivity_MembersInjector.create(mainPresenterProvider); &#125; @Override public void inject(MainActivity activity) &#123; mainActivityMembersInjector.injectMembers(activity); &#125; public static final class Builder &#123; private MainModule mainModule; private Builder() &#123;&#125; public MainComponent build() &#123; if (mainModule == null) &#123; throw new IllegalStateException(MainModule.class.getCanonicalName() + " must be set"); &#125; return new DaggerMainComponent(this); &#125; public Builder mainModule(MainModule mainModule) &#123; this.mainModule = Preconditions.checkNotNull(mainModule); return this; &#125; &#125;&#125; 在 MainComponent 里定义的Inject方法的实现里调用了mainActivityMembersInjector.injectMembers(activity)方法，将我们的 MainActivity 注入到该类中。 MainActivity_MembersInjector所对应的注入类。 1234567891011121314151617181920212223242526public final class MainActivity_MembersInjector implements MembersInjector&lt;MainActivity&gt; &#123; private final Provider&lt;MainPresenter&gt; mainPresenterProvider; public MainActivity_MembersInjector(Provider&lt;MainPresenter&gt; mainPresenterProvider) &#123; assert mainPresenterProvider != null; this.mainPresenterProvider = mainPresenterProvider; &#125; public static MembersInjector&lt;MainActivity&gt; create( Provider&lt;MainPresenter&gt; mainPresenterProvider) &#123; return new MainActivity_MembersInjector(mainPresenterProvider); &#125; @Override public void injectMembers(MainActivity instance) &#123; if (instance == null) &#123; throw new NullPointerException("Cannot inject members into a null reference"); &#125; instance.mainPresenter = mainPresenterProvider.get(); &#125; public static void injectMainPresenter( MainActivity instance, Provider&lt;MainPresenter&gt; mainPresenterProvider) &#123; instance.mainPresenter = mainPresenterProvider.get(); &#125;&#125; 最后将mainPresenterProvider中创建好的 MainPresenter 实例赋值给instance(MainActivity)的成员 mainPresenter，这样我们用@Inject标注的 mainPresenter 就得到了实例化，接着就可以在代码中使用了。]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus]]></title>
    <url>%2F2018%2F04%2F03%2FEventBus%2F</url>
    <content type="text"><![CDATA[EventBus 基于观察者模式的 Android 事件分发总线。它使得 事件发送 和 事件接收 很好地解耦。另外使得 Android 组件之间的通信变得简单，代码变得整洁。 EventBus 的三个步骤 注册订阅者 事件发布 反注册订阅者 注册订阅者1EventBus.getDefault().register(this); getDefault()是一个DoubleCheckLock的单例模式获取到实例。再看一下 EventBus 的构造方法 1234567891011121314151617181920212223242526public EventBus() &#123; this(DEFAULT_BUILDER);&#125;EventBus(EventBusBuilder builder) &#123; subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; eventInheritance = builder.eventInheritance; executorService = builder.executorService;&#125;public EventBus build() &#123; return new EventBus(this);&#125; 默认的构造方法又调用参数为EventBusBuilder的构造方法，构造出 EventBus 的实例。 接下来看register() 123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); // 获取订阅者的订阅方法并用List封装 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; // 逐个订阅 for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; register()接收参数为 Object 类型的订阅者，通常也就是代码中 Activity 和 Fragment 的实例 this。subscriberMethodFinder是 EventBus 的一个成员，可以看作是一个订阅方法查找器。调用findSubscriberMethods方法，传入订阅者的 Class 对象，字面意思是找出订阅者中所有的订阅方法，用一个 List 集合来接收。 12345678910111213141516171819202122List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; if (ignoreGeneratedIndex) &#123; // 使用反射方式获取 subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; // 使用SubscriberIndex方式获取 subscriberMethods = findUsingInfo(subscriberClass); &#125; // 若订阅者中没有订阅方法，则抛异常 if (subscriberMethods.isEmpty()) &#123; throw new EventBusException("Subscriber " + subscriberClass + " and its super classes have no public methods with the @Subscribe annotation"); &#125; else &#123; // 缓存订阅者的订阅方法List METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125;&#125; METHOD_CACHE是一个 Map，以订阅者的 Class 对象为 key，订阅者中的订阅方法 List 为 value，缓存了注册过的订阅方法。ignoreGeneratedIndex这个属性默认为 false，当为 tru 时，表示以反射的方式获取订阅者中的订阅方法，当为 false 时，则以Subscriber Index的方式获取。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 使用反射方式获取private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123; // 创建并初始化FindState对象 FindState findState = prepareFindState(); // findState与subscriberClass关联 findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; // 使用反射的方式获取单个类的订阅方法 findUsingReflectionInSingleClass(findState); // 使findState.clazz指向父类的Class，继续获取 findState.moveToSuperclass(); &#125; // 返回订阅者极其父类的订阅方法List，并释放资源 return getMethodsAndRelease(findState);&#125;private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; for (Method method : methods) &#123; int modifiers = method.getModifiers(); // 忽略非public的方法和static等修饰的方法 if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; // 获取订阅方法的所有参数 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); // 订阅方法只能有一个参数，否则忽略 if (parameterTypes.length == 1) &#123; // 获取注解 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; // 获取第一个参数 Class&lt;?&gt; eventType = parameterTypes[0]; // 检查eventType决定是否订阅，通常订阅者不能有多个eventType相同的订阅方法 if (findState.checkAdd(method, eventType)) &#123; // 获取线程模式 ThreadMode threadMode = subscribeAnnotation.threadMode(); // 添加订阅方法进List findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException("@Subscribe method " + methodName + "must have exactly 1 parameter but has " + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException(methodName + " is a illegal @Subscribe method: must be public, non-static, and non-abstract"); &#125; &#125;&#125; 经过修饰符、参数个数、是否有注解、和订阅者是否有eventType相同的方法几层条件的筛选，最终将订阅方法添加进findState的subscriberMethods这个 List 中。 123456789101112131415161718192021222324252627282930313233343536373839404142// 使用SubscriberIndex方式获取private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; // 获取当前clazz对应的SubscriberInfo findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; // 通过SubscriberInfo获取阅方法数组 SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); // 逐个添加进findState.subscriberMethods for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; // 若SubscriberInfo为空，则采用反射方式获取 findUsingReflectionInSingleClass(findState); &#125; findState.moveToSuperclass(); &#125;&#125;private SubscriberInfo getSubscriberInfo(FindState findState) &#123; if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) &#123; SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo(); if (findState.clazz == superclassInfo.getSubscriberClass()) &#123; return superclassInfo; &#125; &#125; if (subscriberInfoIndexes != null) &#123; for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123; // 通过SubscriberIndex获取findState.clazz对应的SubscriberInfo SubscriberInfo info = index.getSubscriberInfo(findState.clazz); if (info != null) &#123; return info; &#125; &#125; &#125; return null;&#125; 这时候主角出现了，我们看subscriberInfoIndexes，它是一个 List，类型为Subscriber Index，订阅者索引，是由 EventBus 注解处理器生成的。 无论通过哪种方式获取，获取到订阅方法 List 之后，接下来是真正订阅的过程。 12345synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// Must be called in synchronized blockprivate void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; Class&lt;?&gt; eventType = subscriberMethod.eventType; // 创建Subscription封装订阅者和订阅方法信息 Subscription newSubscription = new Subscription(subscriber, subscriberMethod); // 根据事件类型从subscriptionsByEventType这个Map中获取Subscription集合 CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); // 若Subscription集合为空，创建并put进Map中 if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; // 若集合中已包含该Subscription则抛异常 if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event " + eventType); &#125; &#125; int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; // 按照优先级插入Subscription if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; // typesBySubscriber与subscriptionsByEventType类似 // 用来存放订阅者中的事件类型 List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); // 订阅方法是否设置黏性模式 if (subscriberMethod.sticky) &#123; // 是否设置了事件继承 if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); // 判断当前事件类型是否为黏性事件或者其子类 if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); // 执行设置了sticky模式的订阅方法 checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125;&#125; subscriptionsByEventType：以事件类型为 key，拥有相同事件类型的订阅方法 List 为 value，存放所有的订阅方法。 typesBySubscriber：以订阅者为 key，订阅者订阅的所有事件类型 List 为 value，存放所有的事件类型。 事件发布1EventBus.getDefault().post(new UpdateUIEvent()); 12345678910111213141516171819202122232425/** Posts the given event to the event bus. */public void post(Object event) &#123; // 获取当前线程的posting状态 PostingThreadState postingState = currentPostingThreadState.get(); List&lt;Object&gt; eventQueue = postingState.eventQueue; // 将事件添加进当前线程的事件队列 eventQueue.add(event); // 判断当前线程是否正在发布事件 if (!postingState.isPosting) &#123; postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; // 取消发布状态没有重置，抛异常 if (postingState.canceled) &#123; throw new EventBusException("Internal error. Abort state was not reset"); &#125; try &#123; while (!eventQueue.isEmpty()) &#123; PostingThreadState(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125; EventBus 用ThreadLocal存储每个线程的PostingThreadState，一个存储了事件发布状态的类，当 post 一个事件时，添加到事件队列末尾，等待前面的事件发布完毕后再拿出来发布，这里看事件发布的关键代码PostingThreadState()。 12345678910111213141516171819202122232425private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; if (eventInheritance) &#123; List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); // 发布事件 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; // 发布事件 subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; Log.d(TAG, "No subscribers registered for event " + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125;&#125; 继续看发布事件的关键代码postSingleEventForEventType()。 12345678910111213141516171819202122232425262728private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; // 根据事件类型找出相关的订阅信息 subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; // 发布事件到具体的订阅者 postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false;&#125; 如果该事件有订阅信息，则执行postToSubscription()。 123456789101112131415161718192021222324252627282930313233343536private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; // 订阅线程跟随发布线程 case POSTING: // 订阅线程和发布线程相同，直接订阅 invokeSubscriber(subscription, event); break; // 订阅线程为主线程 case MAIN: if (isMainThread) &#123; // 发布线程和订阅线程都是主线程，直接订阅 invokeSubscriber(subscription, event); &#125; else &#123; // 发布线程不是主线程，订阅线程切换到主线程订阅 mainThreadPoster.enqueue(subscription, event); &#125; break; // 订阅线程为后台线程 case BACKGROUND: if (isMainThread) &#123; // 发布线程为主线程，切换到后台线程订阅 backgroundPoster.enqueue(subscription, event); &#125; else &#123; // 发布线程不为主线程，直接订阅 invokeSubscriber(subscription, event); &#125; break; // 订阅线程为异步线程 case ASYNC: // 使用线程池线程订阅 asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode); &#125;&#125; 看到四种线程模式： POSTING：事件发布在什么线程，就在什么线程订阅。 MAIN：无论事件在什么线程发布，都在主线程订阅。 BACKGROUND：如果发布的线程不是主线程，则在该线程订阅，如果是主线程，则使用一个单独的后台线程订阅。 ASYNC：在非主线程和发布线程中订阅。 继续看实现订阅者的方法invokeSubscriber()。 123456789void invokeSubscriber(Subscription subscription, Object event) &#123; try &#123; subscription.subscriberMethod.method.invoke(subscription.subscriber, event); &#125; catch (InvocationTargetException e) &#123; handleSubscriberException(subscription, event, e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new IllegalStateException("Unexpected exception", e); &#125;&#125; 订阅者接收到了事件，调用订阅方法，传入发布的事件作为参数，至此，事件发布过程就结束了。 反注册订阅者1EventBus.getDefault().unregister(this); 123456789101112/** Unregisters the given subscriber from all event classes. */public synchronized void unregister(Object subscriber) &#123; List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) &#123; for (Class&lt;?&gt; eventType : subscribedTypes) &#123; unsubscribeByEventType(subscriber, eventType); &#125; typesBySubscriber.remove(subscriber); &#125; else &#123; Log.w(TAG, "Subscriber to unregister was not registered before: " + subscriber.getClass()); &#125;&#125; 这里根据订阅者拿到订阅事件类型 List，然后逐个取消订阅，调用unsubscribeByEventType()方法。 12345678910111213141516/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123; List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions != null) &#123; int size = subscriptions.size(); for (int i = 0; i &lt; size; i++) &#123; Subscription subscription = subscriptions.get(i); if (subscription.subscriber == subscriber) &#123; subscription.active = false; subscriptions.remove(i); i--; size--; &#125; &#125; &#125;&#125; subscriptionsByEventType是存储事件类型对应订阅信息的 Map，代码逻辑非常清晰，找出某事件类型的订阅信息 List，遍历订阅信息，将要取消订阅的订阅者和订阅信息封装的订阅者比对，如果是同一个，则说明该订阅信息是将要失效的，于是将该订阅信息移除。]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit]]></title>
    <url>%2F2018%2F04%2F03%2FRetrofit%2F</url>
    <content type="text"><![CDATA[Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装。网络请求的工作本质上是 OkHttp 完成，而 Retrofit 仅负责网络请求接口的封装。 Retrofit 的本质流程 具体过程： 通过解析网络请求接口的注解、配置、网络请求参数 通过动态代理生成网络请求对象 通过网络请求适配器对网络请求对象进行平台适配 通过网络请求执行器发送网络请求 通过数据转换器解析服务器返回的数据 通过回调执行器切换线程 用户在主线程处理返回结果 下面介绍上面提到的几个角色 源码分析Retrofit 的使用步骤： 创建 Retrofi 实例 创建网络请求接口实例并配置网络请求参数 发送网络请求 处理服务器返回的数据 创建 Retrofit 实例 步骤1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;-- Retrofit类 --&gt;public final class Retrofit &#123; private final Map&lt;Method, ServiceMethod&gt; serviceMethodCache = new LinkedHashMap&lt;&gt;(); // 网络请求配置对象（对网络请求接口中方法注解进行解析后得到的对象） // 作用：存储网络请求相关的配置，如网络请求的方法、数据转换器、网络请求适配器、网络请求工厂、基地址等 private final HttpUrl baseUrl; // 网络请求的url地址 private final okhttp3.Call.Factory callFactory; // 网络请求器的工厂 // 作用：生产网络请求器（Call） // Retrofit是默认使用okhttp private final List&lt;CallAdapter.Factory&gt; adapterFactories; // 网络请求适配器工厂的集合 // 作用：放置网络请求适配器工厂 // 网络请求适配器工厂作用：生产网络请求适配器（CallAdapter） // 下面会详细说明 private final List&lt;Converter.Factory&gt; converterFactories; // 数据转换器工厂的集合 // 作用：放置数据转换器工厂 // 数据转换器工厂作用：生产数据转换器（converter） private final Executor callbackExecutor; // 回调方法执行器 private final boolean validateEagerly; // 标志位 // 作用：是否提前对业务接口中的注解进行验证转换的标志位 &lt;-- Retrofit类的构造函数 --&gt; Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl, List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; adapterFactories, Executor callbackExecutor, boolean validateEagerly) &#123; this.callFactory = callFactory; this.baseUrl = baseUrl; this.converterFactories = unmodifiableList(converterFactories); this.adapterFactories = unmodifiableList(adapterFactories); // unmodifiableList(list)近似于UnmodifiableList&lt;E&gt;(list) // 作用：创建的新对象能够对list数据进行访问，但不可通过该对象对list集合中的元素进行修改 this.callbackExecutor = callbackExecutor; this.validateEagerly = validateEagerly; ... // 仅贴出关键代码 &#125;&#125; 成功建立一个 Retrofit 对象的标准：配置好 Retrofit 类里的成员变量 serviceMethod：包含所有网络请求信息的对象 baseUrl：网络请求的url地址 callFactory：网络请求工厂 adapterFactories：网络请求适配器工厂的集合 converterFactories：数据转换器工厂的集合 callbackExecutor：回调方法执行器 CallAdapter详细介绍 定义：网络请求执行器（Call）的适配器 Call 在 Retrofit 里默认是OkHttpCall 在 Retrofit 中提供了四种CallAdapterFactory： ExecutorCallAdapterFactory（默认）、GuavaCallAdapterFactory、Java8CallAdapterFactory、RxJavaCallAdapterFactory 作用：将默认的网络请求执行器（OkHttpCall）转换成适合被不同平台来调用的网络请求执行器形式 一开始Retrofit只打算利用OkHttpCall通过ExecutorCallbackCall切换线程；但后来发现使用Rxjava更加方便（不需要Handler来切换线程）。想要实现Rxjava的情况，那就得使用RxJavaCallAdapterFactoryCallAdapter将OkHttpCall转换成Rxjava(Scheduler)： 12// 把response封装成rxjava的Observeble，然后进行流式操作Retrofit.Builder.addCallAdapterFactory(newRxJavaCallAdapterFactory().create()); 步骤2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&lt;-- Builder类--&gt;public static final class Builder &#123; private Platform platform; private okhttp3.Call.Factory callFactory; private HttpUrl baseUrl; private List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); private List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(); private Executor callbackExecutor; private boolean validateEagerly; // 从上面可以发现， Builder类的成员变量与Retrofit类的成员变量是对应的 // 所以Retrofit类的成员变量基本上是通过Builder类进行配置 // 开始看步骤1 &lt;-- 步骤1 --&gt; // Builder的构造方法（无参） public Builder() &#123; this(Platform.get()); // 用this调用自己的有参构造方法public Builder(Platform platform) -&gt;&gt;步骤5（看完步骤2、3、4再看） // 并通过调用Platform.get（）传入了Platform对象 // 继续看Platform.get()方法 -&gt;&gt;步骤2 // 记得最后继续看步骤5的Builder有参构造方法 &#125; ... &#125; &lt;-- 步骤2 --&gt; class Platform &#123; private static final Platform PLATFORM = findPlatform(); // 将findPlatform()赋给静态变量 static Platform get() &#123; return PLATFORM; // 返回静态变量PLATFORM，即findPlatform() -&gt;&gt;步骤3 &#125; &lt;-- 步骤3 --&gt; private static Platform findPlatform() &#123; try &#123; Class.forName("android.os.Build"); // Class.forName(xxx.xx.xx)的作用：要求JVM查找并加载指定的类（即JVM会执行该类的静态代码段） if (Build.VERSION.SDK_INT != 0) &#123; return new Android(); // 此处表示：如果是Android平台，就创建并返回一个Android对象 -&gt;&gt;步骤4 &#125; &#125; catch (ClassNotFoundException ignored) &#123; &#125; try &#123; // 支持Java平台 Class.forName("java.util.Optional"); return new Java8(); &#125; catch (ClassNotFoundException ignored) &#123; &#125; try &#123; // 支持iOS平台 Class.forName("org.robovm.apple.foundation.NSObject"); return new IOS(); &#125; catch (ClassNotFoundException ignored) &#123; &#125; // 从上面看出：Retrofit2.0支持3个平台：Android平台、Java平台、IOS平台 // 最后返回一个Platform对象（指定了Android平台）给Builder的有参构造方法public Builder(Platform platform) --&gt; 步骤5 // 说明Builder指定了运行平台为Android return new Platform(); &#125; ... &#125; &lt;-- 步骤4 --&gt; // 用于接收服务器返回数据后进行线程切换在主线程显示结果 static class Android extends Platform &#123; @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); // 创建默认的网络请求适配器工厂 // 该默认工厂生产的 adapter 会使得Call在异步调用时在指定的 Executor 上执行回调 // 在Retrofit中提供了四种CallAdapterFactory： ExecutorCallAdapterFactory（默认）、GuavaCallAdapterFactory、Java8CallAdapterFactory、RxJavaCallAdapterFactory // 采用了策略模式 &#125; @Override public Executor defaultCallbackExecutor() &#123; // 返回一个默认的回调方法执行器 // 该执行器作用：切换线程（子-&gt;&gt;主线程），并在主线程（UI线程）中执行回调方法 return new MainThreadExecutor(); &#125; static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); // 获取与Android 主线程绑定的Handler @Override public void execute(Runnable r) &#123; handler.post(r); // 该Handler是上面获取的与Android 主线程绑定的Handler // 在UI线程进行对网络请求返回数据处理等操作。 &#125; &#125; // 切换线程的流程： // 1. 回调ExecutorCallAdapterFactory生成了一个ExecutorCallbackCall对象 //2. 通过调用ExecutorCallbackCall.enqueue(CallBack)从而调用MainThreadExecutor的execute()通过handler切换到主线程 &#125; // 下面继续看步骤5的Builder有参构造方法 &lt;-- 步骤5 --&gt; // Builder类的构造函数2（有参） public Builder(Platform platform) &#123; // 接收Platform对象（Android平台） this.platform = platform; // 通过传入BuiltInConverters()对象配置数据转换器工厂（converterFactories） // converterFactories是一个存放数据转换器Converter.Factory的数组 // 配置converterFactories即配置里面的数据转换器 converterFactories.add(new BuiltInConverters()); // BuiltInConverters是一个内置的数据转换器工厂（继承Converter.Factory类） // new BuiltInConverters()是为了初始化数据转换器 &#125;&#125; Builder 设置了默认的 平台类型对象：Android 网络请求适配器工厂：CallAdapterFactory 数据转换器工厂： converterFactory 回调执行器：callbackExecutor 步骤3 1234567891011121314151617181920212223242526&lt;-- 步骤1 --&gt;public Builder baseUrl(String baseUrl) &#123; // 把String类型的url参数转化为适合OKhttp的HttpUrl类型 HttpUrl httpUrl = HttpUrl.parse(baseUrl); // 最终返回带httpUrl类型参数的baseUrl（）// 下面继续看baseUrl(httpUrl) -&gt;&gt; 步骤2 return baseUrl(httpUrl);&#125;&lt;-- 步骤2 --&gt;public Builder baseUrl(HttpUrl baseUrl) &#123; //把URL参数分割成几个路径碎片 List&lt;String&gt; pathSegments = baseUrl.pathSegments(); // 检测最后一个碎片来检查URL参数是不是以"/"结尾 // 不是就抛出异常 if (!"".equals(pathSegments.get(pathSegments.size() - 1))) &#123; throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl); &#125; this.baseUrl = baseUrl; return this;&#125; baseUrl()用于配置 Retrofit 类的网络请求 url 地址 步骤4 12345678910111213141516171819202122public final class GsonConverterFactory extends Converter.Factory &#123;&lt;-- 步骤1 --&gt; public static GsonConverterFactory create() &#123; // 创建一个Gson对象 return create(new Gson()); -&gt;&gt;步骤2 &#125;&lt;-- 步骤2 --&gt; public static GsonConverterFactory create(Gson gson) &#123; // 创建了一个含有Gson对象实例的GsonConverterFactory return new GsonConverterFactory(gson); -&gt;&gt;步骤3 &#125; private final Gson gson;&lt;-- 步骤3 --&gt; private GsonConverterFactory(Gson gson) &#123; if (gson == null) throw new NullPointerException("gson == null"); this.gson = gson; &#125;&#125; 123456// 将上面创建的GsonConverterFactory放入到 converterFactories数组// 在第二步放入一个内置的数据转换器工厂BuiltInConverters(）后又放入了一个GsonConverterFactorypublic Builder addConverterFactory(Converter.Factory factory) &#123; converterFactories.add(checkNotNull(factory, "factory == null")); return this;&#125; 创建一个含有 Gson 对象实例的GsonConverterFactory并放入到数据转换器工厂converterFactories里 步骤5 1234567891011121314151617181920212223242526272829303132333435363738public Retrofit build() &#123;&lt;-- 配置网络请求执行器（callFactory）--&gt; okhttp3.Call.Factory callFactory = this.callFactory; // 如果没指定，则默认使用okhttp // 所以Retrofit默认使用okhttp进行网络请求 if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125;&lt;-- 配置回调方法执行器（callbackExecutor）--&gt; Executor callbackExecutor = this.callbackExecutor; // 如果没指定，则默认使用Platform检测环境时的默认callbackExecutor // 即Android默认的callbackExecutor if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125;&lt;-- 配置网络请求适配器工厂（CallAdapterFactory）--&gt; List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); // 向该集合中添加了步骤2中创建的CallAdapter.Factory请求适配器（添加在集合器末尾） adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));// 请求适配器工厂集合存储顺序：自定义1适配器工厂、自定义2适配器工厂...默认适配器工厂（ExecutorCallAdapterFactory）&lt;-- 配置数据转换器工厂：converterFactory --&gt; // 在步骤2中已经添加了内置的数据转换器BuiltInConverters(）（添加到集合器的首位） // 在步骤4中又插入了一个Gson的转换器 - GsonConverterFactory（添加到集合器的首二位） List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); // 数据转换器工厂集合存储的是：默认数据转换器工厂（ BuiltInConverters）、自定义1数据转换器工厂（GsonConverterFactory）、自定义2数据转换器工厂....// 注：//1. 获取合适的网络请求适配器和数据转换器都是从adapterFactories和converterFactories集合的首位-末位开始遍历// 因此集合中的工厂位置越靠前就拥有越高的使用权限 // 最终返回一个Retrofit的对象，并传入上述已经配置好的成员变量 return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly);&#125; 成功创建了 Retrofit 的实例 创建网络请求接口的实例1retrofit.create(XXX.class); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; if (validateEagerly) &#123; // 判断是否需要提前验证 eagerlyValidateMethods(service); // 具体方法作用： // 1. 给接口中每个方法的注解进行解析并得到一个ServiceMethod对象 // 2. 以Method为键将该对象存入LinkedHashMap集合中 // 特别注意：如果不是提前验证则进行动态解析对应方法（下面会详细说明），得到一个ServiceMethod对象，最后存入到LinkedHashMap集合中，类似延迟加载（默认） &#125; // 创建了网络请求接口的动态代理对象，即通过动态代理创建网络请求接口的实例 （并最终返回） // 该动态代理是为了拿到网络请求接口实例上所有注解 return (T) Proxy.newProxyInstance( service.getClassLoader(), // 动态生成接口的实现类 new Class&lt;?&gt;[] &#123; service &#125;, // 动态创建实例 new InvocationHandler() &#123; // 将代理类的实现交给 InvocationHandler类作为具体的实现（下面会解释） private final Platform platform = Platform.get(); // 在 InvocationHandler类的invoke（）实现中，除了执行真正的逻辑（如再次转发给真正的实现类对象），还可以进行一些有用的操作 // 如统计执行时间、进行初始化和清理、对接口调用进行检查等。 @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; // 下面会详细介绍 invoke（）的实现 // 即下面三行代码 ServiceMethod serviceMethod = loadServiceMethod(method); OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125;// 特别注意// return (T) roxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler invocationHandler)// 可以解读为：getProxyClass(loader, interfaces) .getConstructor(InvocationHandler.class).newInstance(invocationHandler);// 即通过动态生成的代理类，调用interfaces接口的方法实际上是通过调用InvocationHandler对象的invoke（）来完成指定的功能// 先记住结论，在讲解步骤4的时候会再次详细说明&lt;-- 关注点1：eagerlyValidateMethods（） --&gt; private void eagerlyValidateMethods(Class&lt;?&gt; service) &#123; Platform platform = Platform.get(); for (Method method : service.getDeclaredMethods()) &#123; if (!platform.isDefaultMethod(method)) &#123; loadServiceMethod(method); &#125; // 将传入的ServiceMethod对象加入LinkedHashMap&lt;Method, ServiceMethod&gt;集合 // 使用LinkedHashMap集合的好处：lruEntries.values().iterator().next()获取到的是集合最不经常用到的元素，提供了一种Lru算法的实现 &#125; &#125; 创建网络接口实例用了外观模式 &amp; 代理模式 通过代理模式中的动态代理模式，动态生成网络请求接口的代理类，并将代理类的实例创建交给InvocationHandler类 作为具体的实现，并最终返回一个动态代理对象。 使用动态代理的好处： 当NetService对象调用getCall（）接口中方法时会进行拦截，调用都会集中转发到InvocationHandler#invoke（），可集中进行处理 获得网络请求接口实例上的所有注解 更方便封装ServiceMethod 12345678910111213141516171819new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable&#123; // 将详细介绍下面代码 // 关注点1 // 作用：读取网络请求接口里的方法，并根据前面配置好的属性配置serviceMethod对象 ServiceMethod serviceMethod = loadServiceMethod(method); // 关注点2 // 作用：根据配置好的serviceMethod对象创建okHttpCall对象 OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); // 关注点3 // 作用：调用OkHttp，并根据okHttpCall返回rejava的Observe对象或者返回Call return serviceMethod.callAdapter.adapt(okHttpCall); &#125;&#125; Retrofit 采用了外观模式统一调用创建网络请求接口实例和网络请求参数配置的方法，具体细节是: 动态创建网络请求接口的实例（代理模式 - 动态代理） 创建 serviceMethod 对象（建造者模式 &amp; 单例模式（缓存机制）） 对 serviceMethod 对象进行网络请求参数配置：通过解析网络请求接口方法的参数、返回值和注解类型，从 Retrofit 对象中获取对应的网络请求的 url 地址、网络请求执行器、网络请求适配器 &amp; 数据转换器。（策略模式） 对 serviceMethod 对象加入线程切换的操作，便于接收数据后通过 Handler 从子线程切换到主线程从而对返回数据结果进行处理（装饰模式） 最终创建并返回一个OkHttpCall类型的网络请求对象 执行网络请求 Retrofit默认使用OkHttp，即OkHttpCall类 OkHttpCall提供了两种网络请求方式： 同步请求：OkHttpCall.execute() 异步请求：OkHttpCall.enqueue() 同步请求 步骤1：对网络请求接口的方法中的每个参数利用对应ParameterHandler进行解析，再根据ServiceMethod对象创建一个OkHttp的Request对象 步骤2：使用OkHttp的Request发送网络请求； 步骤3：对返回的数据使用之前设置的数据转换器（GsonConverterFactory）解析返回的数据，最终得到一个Response&lt;T&gt;对象 异步请求 步骤1：对网络请求接口的方法中的每个参数利用对应ParameterHandler进行解析，再根据ServiceMethod对象创建一个OkHttp的Request对象 步骤2：使用OkHttp的Request发送网络请求； 步骤3：对返回的数据使用之前设置的数据转换器（GsonConverterFactory）解析返回的数据，最终得到一个Response&lt;T&gt;对象 步骤4：进行线程切换从而在主线程处理返回的数据结果 总结Retrofit 本质上是一个RESTful的 HTTP 网络请求框架的封装，即通过大量的设计模式封装了 OkHttp ，使得简洁易用。具体过程如下： Retrofit 将 Http 请求抽象成 Java 接口 在接口里用注解描述和配置网络请求参数 用动态代理的方式，动态将网络请求接口的注解解析成 HTTP 请求 最后执行 HTTP 请求]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp]]></title>
    <url>%2F2018%2F04%2F03%2FOkHttp%2F</url>
    <content type="text"><![CDATA[OkHttp 是一个高效的 HTTP 库: 支持 SPDY ，共享同一个 Socke t来处理同一个服务器的所有请求 如果 SPDY 不可用，则通过连接池来减少请求延时 无缝的支持 GZIP 来减少数据流量 缓存响应数据来减少重复的网络请求 总体设计 请求流程图 OkHttpClient内部缓存有Cache和InternalCache。 先创建OkHttpClient的实例，然后通过Request.Builder()创建Request对象 通过Diapatcher不断从RequestQueue中取出请求（Call），同步请求通过Call.execute()直接返回当前的Response，而异步请求会把当前的请求Call.enqueue()添加（AsyncCall）到请求队列中，并通过回调（Callback） 的方式来获取最后结果。 同步请求和异步请求最后都会通过拦截器链发起请求，根据是否已缓存调用Cache或Network这两类数据获取接口之一，从内存缓存或是服务器取得请求的数据。]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide]]></title>
    <url>%2F2018%2F04%2F03%2FGlide%2F</url>
    <content type="text"><![CDATA[Glide 是 Google 推荐的一套快速高效的图片加载框架，功能强大且使用方便。它在使用上大致分为 with、load、into 三个步骤，接下来将分别围绕这三个方法来解析。 with 方法根据传入的 context 分为 Application 对象，和应用程序的生命周期同步 非 Application 对象，使用隐藏 Fragment（RequestManagerFragment）得到生命周期 with 方法返回了一个RequestManager对象。 load 方法返回默认DrawableTypeRequest对象。指定asBitmap、asGif时分别返回BitmapTypeRequest对象、GifTypeRequest对象。 into 方法RequsetBuilder的into方法中创建了buildRequest，创建请求，调用了Engine的oad方法，最后设置target。 Engine 任务创建，发起，回调，管理存活和缓存的资源 load()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public LoadStatus load( GlideContext glideContext, Object model, Key signature, int width, int height, Class resourceClass, Class transcodeClass, Priority priority, DiskCacheStrategy diskCacheStrategy, Map, Transformation&gt; transformations, boolean isTransformationRequired, Options options, boolean isMemoryCacheable, boolean useUnlimitedSourceExecutorPool, ResourceCallback cb) &#123; Util.assertMainThread(); long startTime = LogTime.getLogTime(); //创建key，这是给每次加载资源的唯一标示。 EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations, resourceClass, transcodeClass, options); //从内存缓存中获取资源，获取成功后会放入到activeResources中 EngineResource cached = loadFromCache(key, isMemoryCacheable); if (cached != null) &#123; //如果有，那么直接利用当前缓存的资源。 cb.onResourceReady(cached, DataSource.MEMORY_CACHE); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Loaded resource from cache", startTime, key); &#125; return null; &#125; //这是一个二级内存的缓存引用，很简单用了一个Map&gt;&gt;装载起来的。 //从存活的资源中加载资源，资源加载完成后，再将这个缓存数据放到一个 value 为软引用的 activeResources map 中，并计数引用数，在图片加载完成后进行判断，如果引用计数为空则回收掉。 EngineResource active = loadFromActiveResources(key, isMemoryCacheable); if (active != null) &#123; cb.onResourceReady(active, DataSource.MEMORY_CACHE); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Loaded resource from active resources", startTime, key); &#125; return null; &#125; //根据key获取缓存的job。 EngineJob current = jobs.get(key); if (current != null) &#123; current.addCallback(cb); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Added to existing load", startTime, key); &#125; return new LoadStatus(cb, current); &#125; //创建job EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable, useUnlimitedSourceExecutorPool); DecodeJob decodeJob = decodeJobFactory.build( glideContext, model, key, signature, width, height, resourceClass, transcodeClass, priority, diskCacheStrategy, transformations, isTransformationRequired, options, engineJob); jobs.put(key, engineJob); engineJob.addCallback(cb); //放入线程池，执行 engineJob.start(decodeJob); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Started new load", startTime, key); &#125; return new LoadStatus(cb, engineJob);&#125; load 调用处理流程图 DecodeJob是整个任务的核心部分。使用了LruCache、弱引用二级内存缓存和DiskLruCache磁盘缓存。 EngineJob 调度DecodeJob，添加，移除资源回调，并 notify 回调。 start(DecodeJob decodeJob) 通过线程池调度一个DecodeJob任务。 MainThreadCallback 实现了Handler.Callback接口，用于Engine任务完成时回调主线程。 DecodeJob 实现了Runnable接口，调度任务的核心类，整个请求的繁重工作都在这里完成：处理来自缓存或者原始的资源，应用转换动画以及transcode。负责根据缓存类型获取不同的Generator加载数据，数据加载成功后回调DecodeJob的onDataFetcherReady方法对资源进行处理。]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler]]></title>
    <url>%2F2018%2F04%2F03%2FHandler%2F</url>
    <content type="text"><![CDATA[Handler 是 Android 消息机制的上层接口，用来解决线程之间的通信。接下来将介绍一下 Handler 的运行机制、Handler所附带的 MessageQueue 和 Looper 的工作过程。 Handler 工作流程浅析 异步通信准备 =&gt; 消息入队 =&gt; 消息循环 =&gt; 消息处理 异步通信准备假定是在主线程创建Handler，则会直接在主线程中创建处理器对象 Looper、消息队列对象 MessageQueue 和 Handler 对象。需要注意的是，Looper 和 MessageQueue 均是属于其 创建线程 的。Looper 对象的创建一般通过 Looper.prepareMainLooper() 和 Looper.prepare() 两个方法，而创建 Looper 对象的同时，将会自动创建 MessageQueue，创建好 MessageQueue 后，Looper 将自动进入消息循环。此时，Handler 自动绑定了主线程的 Looper 和 MessageQueue。 消息入队工作线程通过 Handler 发送消息 Message 到消息队列 MessageQueue 中，消息内容一般是 UI 操作。发送消息一般都是通过 Handler.sendMessage(Message msg) 和 Handler.post(Runnabe r) 两个方法来进行的。而入队一般是通过 MessageQueue.enqueueeMessage(Message msg,long when) 来处理。 消息循环主要分为「消息出队」和「消息分发」两个步骤，Looper 会通过循环 取出 消息队列 MessageQueue 里面的消息 Message，并 分发 到创建该消息的处理者 Handler。如果消息循环过程中，消息队列 MessageQueue 为空队列的话，则线程阻塞。 消息处理 Handler 接收到 Looper 发来的消息，开始进行处理。 对于 Handler ，一些需要注意的地方 1 个线程 Thread 只能绑定 1个循环器 Looper，但可以有多个处理者 Handler 1 个循环器 Looper 可绑定多个处理者 Handler 1 个处理者 Handler 只能绑定 1 个 1 个循环器 Looper 消息机制具体流程分析 Handler通过sendMessage或者post发送消息，最后都会调用sendMessageAtTime将Message交给MessageQueue MessageQueue调用其enqueueMessage方法将Message以链表的形式放入队列中 Looper的loop方法循环调用MessageQueue.next()取出消息，通过msg.target获取目标Handler，并且调用Handler的dispatchMessage来处理消息 在dispatchMessage中，分别判断msg.callback也就是post方法、mCallback也就是构造方法传入的Callback不为空就执行他们的回调，如果都为空就执行我们最常用重写的handleMessage。 最后谈谈 Handler 的内存泄露问题当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有 Activity 的引用，即可能会造成内存泄漏。 解决方法：静态内部类 + 弱引用。 12345678910111213static class MyHandler extends Handler &#123; WeakReference&lt;Activity &gt; mActivityReference; MyHandler(Activity activity) &#123; mActivityReference= new WeakReference&lt;Activity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; final Activity activity = mActivityReference.get(); if (activity != null) &#123; mImageView.setImageBitmap(mBitmap); &#125; &#125;&#125; 关于 HandlerThread 和 IntentService**HandlerThread**是一种可以使用Handler的 Thread。普通的 Thread 主要用于在 run 方法中执行一个耗时任务，而HandlerThread在内部创建了消息队列，外界需要通过Handler的消息方式来通知其执行一个具体的任务。 **IntentService**封装了HandlerThread和Handler。 工作流程如下： 在onCreate方法中创建了一个HandlerThread，然后使用它的Looper来构造一个Handler对象mServiceHandler。 在onStartCommand中调用了onStart，在onStart中把传进来的Intent通过mServiceHandler的sendMessage方法发送出去。 mServiceHandler在其handleMessage方法中先调用onHandlerIntent，执行完任务后调用stopSelf终止服务。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>source code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 性能优化]]></title>
    <url>%2F2018%2F04%2F03%2FAndroid%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[本文主要介绍了一些 Android 的性能优化方法和程序设计的思想，在日常开发中经常使用，将有助于提高 Android 程序的性能，提升用户体验。 布局优化使用&lt;include&gt;、&lt;merge&gt;、&lt;ViewStub&gt;标签 绘制优化不要在 onDraw 方法中创建新的对象和做耗时的任务 内存泄露优化 静态变量导致的内存泄露 单例模式导致的内存泄露 属性动画及各种连接没有关闭导致的内存泄露 非静态内部类导致的内存泄露 响应速度优化ANR 日志分析 线程优化采用线程池 性能优化建议 避免创建过多的对象 常量使用static final修饰 使用 Android 特有的数据结构，比如SparseArray、Pair 适当使用软引用和弱引用 采用内存缓存和磁盘缓存 尽量采用静态内部类]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2018%2F04%2F03%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法进行了整理。 懒汉式，线程不安全1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 懒汉式，线程安全123456public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance;&#125; 双重检验锁123456789101112131415public class Singleton &#123; private volatile static Singleton instance; //声明成 volatile private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 饿汉式12345678910public class Singleton&#123; //类加载时就初始化 private static final Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 静态内部类123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 枚举123public enum EasySingleton&#123; INSTANCE;&#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 的事件分发机制]]></title>
    <url>%2F2018%2F04%2F03%2FView%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在 Android 开发中，事件分发机制是一块 Android 比较重要的知识体系，了解并熟悉整套的分发机制有助于更好的分析各种点击滑动失效问题，更好去扩展控件的事件功能和开发自定义控件。 Tips： 改变 View 的位置可以通过： 使用动画 改变布局参数 点击事件的分发过程由三个方法来共同完成，分别是： dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent。 三者的关系可以用如下代码来表示： 12345678910public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; 点击事件的传递规则 正常情况下，一个事件序列只能被一个 View 拦截且消耗。 某个 View 一旦决定拦截，那么这一个事件序列都只能由它来处理（如果事件序到能够传递给它的话），并且它的onlnterceptTouchEvent不会再被调用。 某个 View 一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了 false），那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新交由它的父元素去处理，即父元素的onTouchEvent会被调用。 如果 View 不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前 View 可以持续收到后续的事件，最终这些消失的点击事件会传递给 Activity 处理。 ViewGroup 默认不拦截任何事件，Android 源码中 ViewGroup 的onInterceptTouchEvent方法默认返回 false。 View 没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。 View 的onTouchEvent默认都会消耗事件（返回 true），除非它是不可点击的（clickable 和 longClickable 同时为 false），View 的 longClickable 属性默认都为 false，clickable 属性要分情况，比如 Button 的 clickable 属性默认为 true，而 TextView 的 clickable 属性默认为 false。 View 的 enable 属性不影响onTouchEvent的默认返回值。哪怕一个 View 是 disable 状态的，只要它的 clickable 或者 longClickable 有一个为 true，那么它的onTouchEvent就返回 true。 onClick 会发生的前提是当前 View 是可点击的，并且它收到了 down 和 up 的事件。 事件传递过程都是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子 View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程。但是ACTION_DOWN事件除外。 事件分发的源码解析Activity 对点击事件的分发过程 Activity 的dispatchTouchEvent方法 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 首先事件开始交给 Activity 所附属的 Window 进行分发，如果返回 true，整个事件循环就结束了，返回 false 意味着事件没人处理，所有 View 的onTouchEvent返回了 false，那么 Activity 的onTouchEvent就会被调用。Window 的实例 PhoneWindow 将事件直接传递给了 DecorView。 顶级 View 对点击事件的分发过程 ViewGroup 的dispatchTouchEvent方法 123456789101112131415final boolean intercepted;if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;&#125; 当事件类型为ACTION_DOWN或者mFirstTouchTarget != null时会判断是否要拦截当前事件。当 ViewGroup 不拦截事件并将事件交给子元素处理时，mFirstTouchTarget会被赋值并指向子元素，mFirstTouchTarget != null。反过来，一旦事件由当前 ViewGroup 拦截，mFirstTouchTarget != null就不成立，那么当ACTION_MOVE和ACTION_UP事件到来时，ViewGroup 的onInterceptTouchEvent不会在被调用，并且同一序列中的其他事件都会默认交给它处理。 这里要注意FLAG_DISALLOW_INTERCEPT标记位，它是通过requestDisallowInterceptTouchEvent方法来设置的，它一旦设置后，ViewGroup 将无法拦截除了ACTION_DOWN以外的其他点击事件。因为当面对ACTION_DOWN事件时，ViewGroup 总是会调用自己的onInterceptTouchEvent方法来询问是否要拦截事件，在下面的代码中，ViewGroup 也会在ACTION_DOWN事件到来时做重置状态的操作。 1234if (actionMasked == MotionEvent.ACTION_DOWN) &#123; cancelAndClearTouchTargets(ev); resetTouchState();&#125; 当 ViewGroup 不拦截事件时，事件会向下分发交给它的子 View 进行处理。 View 对点击事件的处理过程 View 的dispatchTouchEvent方法 12345678910111213141516171819202122public boolean dispatchTouchEvent(MotionEvent event) &#123; boolean result = false; ... if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; ... return result;&#125; View 首先会判断有没有设置OnTouchListener，如果OnTouchListener中的onTouch方法返回 true，那么onTouchEvent就不会被调用，可见OnTouchListener的优先级高于onTouchEvent。 接下来再分析onTouchEvent的实现。当 View 处于不可用状态下时，也会消耗点击事件，尽管它看起来不可用。 12345678if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (event.getAction() == MotionEvent.ACTION_UP &amp;;&amp;; (mPrivateFlags &amp;; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp;; CLICKABLE) == CLICKABLE || (viewFlags &amp;; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; 下面再看一下onTouchEvent中对点击事件的具体处理 12345678910111213141516171819202122232425if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0; if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) &#123; ... if (!mHasPerformedLongPress) &#123; removeLongPressCallback(); if (!focusTaken) &#123; if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; ... &#125; break; &#125; ... return true;&#125; 可见只要 View 的 CLICKABLE 和 LONG_CLICKABLE 有一个为 true，它就会消耗这个事件，即onTouchEvent方法返回 true。然后就是当ACTION_UP事件发生时，会触发performClick方法，如果 View 设置了OnClickListener，那么它的onClick方法会被调用。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>source code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 四大组件]]></title>
    <url>%2F2018%2F04%2F02%2FAndroid%20%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Android 系统对四大组件的过程进行了很大程度的封装，本文侧重于对四大组件工作过程的分析，通过分析他们的工作过程理解系统内部运行机制，加深我们对 Android 整体系统结构的认识。 Tips： 除了BroadcastReceiver，其他三种组件都必须AndroidManifest中注册 除了ContentProvider，其他三种组件需要借助Intent Activity 启动过程 startActivity方法有好几种重载方式，但最终都会调用startActivityForResult方法，在其中调用了Instrumentation的execStartActivity方法。 在Instrumentation的execStartActivity方法中先通过ActivityManagerNative.getDefault得到 AMS 对象，调用其startActivity方法，最后执行checkStartActivityResult来检查启动 Activity 的结果。 ActivityManagerService调用ActivityStarter.startActivityMayWait。经过一系列复杂的调用，收集并记录 Activity 的启动信息，调整 ActivityStack（让栈顶的 Activity 进入 pause 状态）。 最后在ActivityStackSupervisor的realStartActivityLocked方法调用app.thread.scheduleLaunchActivity方法。也就是说，ActivityManagerService调用ApplicationThread的scheduleLaunchActivity接口方法，在其中通过 Handler 发送了一个LAUNCH_ACTIVITY的消息。 在 Handler 的handlerMessage方法中调用了ActivityThread的handlerLaunchActivity方法，在其中又执行了performLaunchActivity方法。 performLaunchActivity方法主要完成了如下几件事： 从ActivityClientRecord中获取带启动的 Activit 的组件信息 通过Instrumentation的newActivity方法使用类加载器创建 Activity 对象 通过LoadedApk的makeApplication方法来尝试创建 Application 对象 创建ContextImpl对象并通过 Activity 的 attach 方法来完成一些重要数据的初始化 调用 Activity 的 onCreate 方法 最终执行 ActivityThread 的handlerResumeActivity方法，然后调用 Activity 的 onResume 方法和 makeVisible 方法，把 decorView 添加到 WindowManage。 Service 启动过程 Service 的启动过程从ContextWrapper的startService开始，调用了ContextImpl的startService，在其中执行了startServiceCommon方法。 startServiceCommon方法中先通过ActivityManagerNative.getDefault得到 AMS 对象，调用其startService方法，经过一系列复杂的调用，最后在realStartServiceLocked方法调用app.thread.scheduleCreateService方法。也就是说，ActivityManagerService调用ApplicationThread的scheduleCreateService接口方法，在其中通过 Handler 发送了一个CREATE_SERVICE的消息。 在 Handler 的handlerMessage方法中调用了ActivityThread的handlerCreateService方法。 首先通过类加载器创建 Service 对象 尝试创建 Application 对象 创建ContextImpl对象并通过 Service 的 attach 方法来完成一些重要数据的初始化 调用 Service 的 onCreate 方法 最终执行 ActivityThread 的handlerServiceArgs方法调用 Service 的onStartCommand方法。 Service 绑定过程 Service 的绑定过程从ContextWrapper的bindService开始，调用了ContextImpl的bindService，在其中执行了bindServiceCommon方法。 bindServiceCommon方法中先通过ActivityManagerNative.getDefault得到 AMS 对象，调用其bindService方法，经过一系列复杂的调用，最后在realStartServiceLocked方法调用app.thread.scheduleBindService方法。也就是说，ActivityManagerService调用ApplicationThread的scheduleBindService接口方法，在其中通过 Handler 发送了一个BIND_SERVICE的消息。 在 Handler 的handlerMessage方法中调用了ActivityThread的handlerBindService方法。 首先 Service 的 token 取出 Service 对象 调用 Service 的 onBind 方法 调用 AMS 的publishService通知客户端成功连接 Service BroadcastReceiver 工作过程广播的注册过程 静态注册：在AndroidManifest中注册，是由 PMS 来完成整个注册过程的。动态注册：从ContextWrapper的registerReceiver开始，调用了ContextImpl的registerReceiver，在其中执行了registerReceiverInternal方法。通过ActivityManagerNative.getDefault得到 AMS 对象，调用其registerReceiver方法来完成注册。 广播的发送和接受过程 从ContextWrapper的sendBroadcast开始，调用了ContextImpl的sendBroadcast方法，通过ActivityManagerNative.getDefault得到 AMS 对象，调用其broadcastIntent方法。 AMS 会根据 intent-filter 查找出匹配的广播接收者添加到BroadcastQuene中，最后调用了ApplicationThread的scheduleRegisteredReceiver接口方法，他通过InnerReceiver来实现广播的接收。 InnerReceiver最终会执行 BroadcastReceiver 的 onReceive 方法。 ContentProvider 工作过程ContentProvider 的 onCreate 要优先于 Application 的 onCreate 而执行。 当一个应用启动或是 ContentProvider 所在的进程被 AMS 启动后，其入口方法为ActivityThread的 main 方法，它是一个静态方法，首先会创建ActivityThread的实例，然后执行其 attach 方法将ApplicationThread对象通过 AMS 的attachApplication方法跨进程传递给 AMS。 AMS 的attachApplication方法调用了attachApplicationLocked方法，attachApplicationLocked方法中又调用了ApplicationThread的bindApplication，在其中通过 Handler 发送了一个BIND_APPLICATION的消息。 在 Handler 的handlerMessage方法中调用了ActivityThread的handlerBindApplication方法。 创建 ContextImpl 和 Instrumentation 创建 Application 对象 启动当前进程的 ContentProvider 并调用其 onCreate 方法 调用 Application 的 onCreate 方法]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>source code</tag>
      </tags>
  </entry>
</search>
