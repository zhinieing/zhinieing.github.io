<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android四大组件]]></title>
    <url>%2F2018%2F04%2F02%2FAndroid%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Tips： 除了BroadcastReceiver，其他三种组件都必须AndroidManifest中注册 除了ContentProvider，其他三种组件需要借助Intent Activity启动过程 startActivity方法有好几种重载方式，但最终都会调用startActivityForResult方法，在其中调用了Instrumentation的execStartActivity方法。 在Instrumentation的execStartActivity方法中先通过ActivityManagerNative.getDefault得到AMS对象，调用其startActivity方法，最后执行checkStartActivityResult来检查启动Activity的结果。 ActivityManagerService调用ActivityStarter.startActivityMayWait。经过一系列复杂的调用，收集并记录Activity的启动信息，调整ActivityStack(让栈顶的Activity进入pause状态)。 最后在ActivityStackSupervisor的realStartActivityLocked方法调用app.thread.scheduleLaunchActivity方法。也就是说，ActivityManagerService调用ApplicationThread的scheduleLaunchActivity接口方法，在其中通过Handler发送了一个LAUNCH_ACTIVITY的消息。 在Handler的handlerMessage方法中调用了ActivityThread的handlerLaunchActivity方法，在其中又执行了performLaunchActivity方法。 performLaunchActivity方法主要完成了如下几件事： 从ActivityClientRecord中获取带启动的Activity的组件信息 通过Instrumentation的newActivity方法使用类加载器创建Activity对象 通过LoadedApk的makeApplication方法来尝试创建Application对象 创建ContextImpl对象并通过Activity的attach方法来完成一些重要数据的初始化 调用Activity的onCreate方法 最终执行ActivityThread的handlerResumeActivity方法，然后调用 Activity 的 onResume 方法和makeVisible 方法，把 decorView 添加到 WindowManage。 Service启动过程 Service的启动过程从ContextWrapper的startService开始，调用了ContextImpl的startService，在其中执行了startServiceCommon方法。 startServiceCommon方法中先通过ActivityManagerNative.getDefault得到AMS对象，调用其startService方法，经过一系列复杂的调用，最后在realStartServiceLocked方法调用app.thread.scheduleCreateService方法。也就是说，ActivityManagerService调用ApplicationThread的scheduleCreateService接口方法，在其中通过Handler发送了一个CREATE_SERVICE的消息。 在Handler的handlerMessage方法中调用了ActivityThread的handlerCreateService方法。 首先通过类加载器创建Service对象 尝试创建Application对象 创建ContextImpl对象并通过Service的attach方法来完成一些重要数据的初始化 调用Service的onCreate方法 最终执行ActivityThread的handlerServiceArgs方法调用Service的onStartCommand方法。 Service绑定过程 Service的绑定过程从ContextWrapper的bindService开始，调用了ContextImpl的bindService，在其中执行了bindServiceCommon方法。 bindServiceCommon方法中先通过ActivityManagerNative.getDefault得到AMS对象，调用其bindService方法，经过一系列复杂的调用，最后在realStartServiceLocked方法调用app.thread.scheduleBindService方法。也就是说，ActivityManagerService调用ApplicationThread的scheduleBindService接口方法，在其中通过Handler发送了一个BIND_SERVICE的消息。 在Handler的handlerMessage方法中调用了ActivityThread的handlerBindService方法。 首先Service的token取出Service对象 调用Service的onBind方法 调用AMS的publishService通知客户端成功连接Service BroadcastReceiver工作过程广播的注册过程 静态注册：在AndroidManifest中注册，是由PMS来完成整个注册过程的。动态注册：从ContextWrapper的registerReceiver开始，调用了ContextImpl的registerReceiver，在其中执行了registerReceiverInternal方法。通过ActivityManagerNative.getDefault得到AMS对象，调用其registerReceiver方法来完成注册。 广播的发送和接受过程 从ContextWrapper的sendBroadcast开始，调用了ContextImpl的sendBroadcast方法，通过ActivityManagerNative.getDefault得到AMS对象，调用其broadcastIntent方法。 AMS会根据intent-filter查找出匹配的广播接收者添加到BroadcastQuene中，最后调用了ApplicationThread的scheduleRegisteredReceiver接口方法，他通过InnerReceiver来实现广播的接收。 InnerReceiver最终会执行BroadcastReceiver的onReceive方法。 ContentProvider工作过程ContentProvider的onCreate要优先于Application的onCreate而执行。 当一个应用启动或是ContentProvider所在的进程被AMS启动后，其入口方法为ActivityThread的main方法，它是一个静态方法，首先会创建ActivityThread的实例，然后执行其attach方法将ApplicationThread对象通过AMS的attachApplication方法跨进程传递给AMS。 AMS的attachApplication方法调用了attachApplicationLocked方法，attachApplicationLocked方法中又调用了ApplicationThread的bindApplication，在其中通过Handler发送了一个BIND_APPLICATION的消息。 在Handler的handlerMessage方法中调用了ActivityThread的handlerBindApplication方法。 创建ContextImpl和Instrumentation 创建Application对象 启动当前进程的ContentProvider并调用其onCreate方法 调用Application的onCreate方法]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>source code</tag>
      </tags>
  </entry>
</search>
