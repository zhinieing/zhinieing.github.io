---
title: 嵌套滑动机制
date: 2018-01-25 10:13:34
categories:
- 源码分析
tags:
- Android
- source code
---
> 嵌套滑动一直是 Android 中比较棘手的问题，根本原因是 Android 的事件分发机制导致的。不过这个问题终于在 API 21之后有了官方的解决方法，就是嵌套滑动机制。

<!--more-->

## 基本原理

嵌套滑动的基本原理是在子控件接收到滑动一段距离的请求时，**先询问父控件**是否要滑动，如果滑动了父控件就通知子控件它**消耗了一部分**滑动距离，子控件就只处理**剩下的**滑动距离，然后子控件滑动完毕后再把剩余的滑动距离传给父控件。



## 具体实现

### API 21之后

> 嵌套滑动的相关逻辑作为**普通方法**直接写进了最新的（API 21之后）`View`和`ViewGroup`类。

### 向前兼容

> 官方在`android.support.v4`兼容包中提供了两个接口`NestedScrollingChild`和`NestedScrollingParent`。两个接口分别定义上面提到的`View`和`ViewParent`新增的普通方法。

### 辅助类

> 除了接口兼容包还提供了`NestedScrollingChildHelper`和`NestedScrollingParentHelper`两个辅助类，这两个辅助类实际上就是对应`View`和`ViewParent`中新增的普通方法。

### 相关方法

#### NestedScrollingChild

> 内控件是嵌套滑动的发起者。

* `startNestedScroll`：起始方法，主要作用是找到接收滑动距离信息的外控件。
* `dispatchNestedPreScroll`：在内控件**处理滑动前**把滑动信息分发给外控件。
* `dispatchNestedScroll`：在内控件**处理完滑动后**把剩下的滑动距离信息分发给外控件。
* `stopNestedScroll`：结束方法，主要作用就是清空嵌套滑动的相关状态。
* `setNestedScrollingEnabled`和`isNestedScrollingEnabled`：一对 get&set 方法，用来判断控件是否支持嵌套滑动。
* `dispatchNestedPreFling`和`dispatchNestedFling`：跟 Scroll 的对应方法作用类似，不过分发的不是滑动信息而是 Fling 信息。 

#### NestedScrollingParent

> 外控件通过`onNestedPreScroll`和`onNestedScroll`来接收内控件响应滑动前后的滑动距离信息。

* `onStartNestedScroll`：对应`startNestedScroll`，内控件通过调用外控件的这个方法来确定外控件是否接收滑动信息。
* `onNestedScrollAccepted`：当外控件确定接收滑动信息后该方法被回调，可以让外控件针对嵌套滑动做一些前期工作。
* `onNestedPreScroll`：关键方法，接收内控件**处理滑动前**的滑动距离信息，在这里外控件可以优先响应滑动操作，消耗部分或者全部滑动距离。
* `onNestedScroll`：关键方法，接收内控件**处理完滑动后**的滑动距离信息，在这里外控件可以选择是否处理剩余的滑动距离。
* `onStopNestedScroll`：对应`stopNestedScroll`，用来做一些收尾工作。
* `getNestedScrollAxes`：返回嵌套滑动的方向，区分横向滑动和竖向滑动，作用不大。
* `onNestedPreFling`和`onNestedFling`：同上略。


## 从 NestedScrollView 看嵌套机制

接下来通过分析相对简单的支持嵌套滑动的容器`NestedScrollView`，来了解下怎样主动调起嵌套滑动的方法，以及嵌套滑动的具体逻辑。`NestedScrollView`简单地说就是支持嵌套滑动的`ScrollView`，内部逻辑简单，而且它既可以是内控件，也可以是外控件，所以选择分析它来了解嵌套滑动机制。

嵌套滑动是从`startNestedScroll`方法开始的，从源码中我们可以发现在两个地方调用了这个方法：

1. `onInterceptTouchEvent`中`ACTION_DOWN`的情况
2. `onTouchEvent`中`ACTION_DOWN`的情况

因为`ACTION_DOWN`是滑动操作的开始事件，所以当接收到这个事件的时候尝试找对应的外控件。只有找到了外控件才有后续的嵌套滑动的逻辑发生。

接着我们看`startNestedScroll`是如何找对应的外控件的，因为`NestedScrollView#startNestedScroll`调用了辅助方法的`startNestedScroll`，所以下面直接看`View#startNestedScroll`。

```java
// View.javapublic 
boolean startNestedScroll(int axes) { 
    // ... 
    if (isNestedScrollingEnabled()) { 
        ViewParent p = getParent(); 
        View child = this; 
        while (p != null) { 
            try { 
                // 关键代码 
                if (p.onStartNestedScroll(child, this, axes)) { 
                    mNestedScrollingParent = p; 
                    p.onNestedScrollAccepted(child, this, axes); 
                    return true; 
                }
            } catch (AbstractMethodError e) { 
                // ... 
            } 
            if (p instanceof View) { 
                child = (View) p; 
            } 
            p = p.getParent(); 
        } 
    } 
    return false;
}
```

遍历父控件，调用父控件的`onStartNestedScroll`，返回 true 表示找到了对应的外控件，找到外控件后马上调用`onNestedScrollAccepted`。所以可以知道：

> 外控件不一定是内控件的直接父控件，但一定是**最近**的符合条件的外控件。

关于`onStartNestedScroll`的方法说明，返回 true 表示接收内控件的滑动信息。对于`NestedScrollView#onStartNestedScroll`内部逻辑很简单，只要是竖直滑动方向就返回 true。所以可以知道：

> `NestedScrollView`不支持横向嵌套滑动。

接着看`NestedScrollView#onNestedScrollAccepted`。

```java
@Overridepublic void onNestedScrollAccepted(View child, View target, int nestedScrollAxes) { 
        mParentHelper.onNestedScrollAccepted(child, target, nestedScrollAxes); 
        startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL);
}
```

辅助类的方法很简单，就是记录当前的滑动方向，在这里`NestedScrollView`又调用`startNestedScroll`来找它自己的外控件，这是为了连续嵌套`NestedScrollView`。

找到了外控件后`ACTION_DOWN`事件就没嵌套滑动的事了，要滑动肯定会在`onTouchEvent`中处理`ACTION_MOVE`事件。

```java
// NestedScrollView#onTouchEvent
case MotionEvent.ACTION_MOVE: 
    // ... 
    final int y = (int) MotionEventCompat.getY(ev, activePointerIndex); 
    int deltaY = mLastMotionY - y; 
    // 让外控件先处理滑动距离 
    if (dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)) { 
        deltaY -= mScrollConsumed[1];// 消耗滑动距离 
        // ... 
    } 
    // ... 
    if (mIsBeingDragged) { 
        // ... 
        // 内控件处理滑动距离 
        if (overScrollByCompat(0, deltaY, 0, getScrollY(), 0, range, 0, 
                      0, true) && !hasNestedScrollingParent()) { 
            // ... 
        } 

        final int scrolledDeltaY = getScrollY() - oldY; 
        final int unconsumedY = deltaY - scrolledDeltaY; 
        if (dispatchNestedScroll(0, scrolledDeltaY, 0, unconsumedY, mScrollOffset)) { 
            // ... 
        } 
        // ... 
    } 
    break;
```

先计算出本次滑动距离`deltaY`，得到滑动距离`deltaY`后，先把它传给`dispatchNestedPreScroll`，然后在结果返回 true 的时候， `delta`会减去`mScrollConsumed[1]`。

```java
// View.java
public boolean dispatchNestedPreScroll(int dx, int dy,
                     @Nullable @Size(2) int[] consumed, @Nullable @Size(2) int[] offsetInWindow) {
    // ... 忽略状态判断 
    consumed[0] = 0; 
    consumed[1] = 0; 
    mNestedScrollingParent.onNestedPreScroll(this, dx, dy, consumed); 
    return consumed[0] != 0 || consumed[1] != 0; 
    // 其他情况返回false
}
```

`dispatchNestedPreScroll`的工作就是把滑动距离在内控件处理前分发给外控件，所以这里的关键代码也很简单，就是直接把相关的参数传给外控件的`onNestedPreScroll`，然后只要外控件消耗了滑动距离（不论横向还是竖向），就会返回 true。

> 外控件如果想在内控件之前消耗滑动距离仅需要在`onNestedPreScroll`把消耗的值放到数组中返回给内控件。

`onNestedPreScroll`是决定外控件的嵌套滑动逻辑的关键方法，**在不同的控件中应该是根据需要有不同的实现的**，而在`NestedScrollView`中就是直接询问它自己的外控件是否消耗滑动距离。在我们自己修改嵌套滑动逻辑的时候需要**注意滑动距离的正负号和内控件处理consumed数组的方式**。

现在外控件已经比内控件先处理了滑动距离了，如果外控件没有完全消耗掉所有滑动距离，这时该内控件处理剩下的滑动距离了。 在`NestedScrollView`中通过`NestedScrollView#overScrollByCompat`来进行滑动，并且滑动结束后通过比对滑动前后的`scrollY`值得到了内控件消耗的滑动距离，然后得到剩下的滑动距离，最后传给`dispatchNestedScroll`。

`dispatchNestedScroll`的逻辑跟`dispatchNestedPreScroll`几乎一样，区别是它调用了外控件的`onNestedScroll`。因为到这里已经是处理滑动距离最后的机会了，所以`onNestedScroll`不会再影响内控件的处理逻辑，`ACTION_MOVE`事件就分析完毕了。

最后就是`stopNestedScroll`了，调用这个方法基本是新的滑动操作开始前，或者滑动操作结束/取消，代码逻辑就是进行一些变量的重置工作和调用`onStopNestedScroll`，而`onStopNestedScroll`也类似。

`NestedScrollView`的嵌套滑动逻辑基本就是这样，它代表了嵌套滑动的"约定"处理方式，虽然不同的控件实际的实现会有不同，不过应该遵循基本方法的调用顺序，确保参数的含义和参数的处理方式。

